{"ast":null,"code":"var _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _classCallCheck2 = _interopRequireDefault(require(\"@babel/runtime/helpers/classCallCheck\"));\n\nvar _createClass2 = _interopRequireDefault(require(\"@babel/runtime/helpers/createClass\"));\n\nvar _util = require(\"./util\");\n\nvar _constants = require(\"./constants\");\n\nvar _Message = _interopRequireDefault(require(\"./Message\"));\n\nvar _default = function () {\n  function _default(payloadMessage) {\n    var messageIdentifier = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n    (0, _classCallCheck2.default)(this, _default);\n    this.messageIdentifier = null;\n    this.type = _constants.MESSAGE_TYPE.PUBLISH;\n    this.payloadMessage = payloadMessage;\n    this.messageIdentifier = messageIdentifier;\n  }\n\n  (0, _createClass2.default)(_default, [{\n    key: \"encode\",\n    value: function encode() {\n      var first = (this.type & 0x0f) << 4;\n      var remLength = 0;\n      var payloadBytes;\n\n      if (this.messageIdentifier) {\n        remLength += 2;\n      }\n\n      if (this.payloadMessage.duplicate) {\n        first |= 0x08;\n      }\n\n      first = first |= this.payloadMessage.qos << 1;\n\n      if (this.payloadMessage.retained) {\n        first |= 0x01;\n      }\n\n      payloadBytes = this.payloadMessage.payloadBytes;\n      var destinationNameLength = (0, _util.lengthOfUTF8)(this.payloadMessage.destinationName);\n      remLength += destinationNameLength + 2;\n      remLength += payloadBytes.byteLength;\n      var mbi = (0, _util.encodeMultiByteInteger)(remLength);\n      var pos = mbi.length + 1;\n      var buffer = new ArrayBuffer(remLength + pos);\n      var byteStream = new Uint8Array(buffer);\n      byteStream[0] = first;\n      byteStream.set(mbi, 1);\n      pos = (0, _util.writeString)(this.payloadMessage.destinationName, destinationNameLength, byteStream, pos);\n\n      if (this.messageIdentifier) {\n        pos = (0, _util.writeUint16)(this.messageIdentifier, byteStream, pos);\n      }\n\n      payloadBytes && byteStream.set(payloadBytes, pos);\n      return buffer;\n    }\n  }]);\n  return _default;\n}();\n\nexports.default = _default;","map":{"version":3,"sources":["C:/Users/venkatesh.devireddy/Projects/IoT_Central_CPM/node_modules/react-native-azure-iotcentral-client/node_modules/react-native-paho-mqtt/src/PublishMessage.js"],"names":["payloadMessage","messageIdentifier","type","MESSAGE_TYPE","PUBLISH","first","remLength","payloadBytes","duplicate","qos","retained","destinationNameLength","destinationName","byteLength","mbi","pos","length","buffer","ArrayBuffer","byteStream","Uint8Array","set"],"mappings":";;;;;;;;;;;AAEA;;AACA;;AACA;;;AAyBE,oBAAYA,cAAZ,EAAwE;AAAA,QAAnCC,iBAAmC,uEAAN,IAAM;AAAA;AAAA,SANxEA,iBAMwE,GAN3C,IAM2C;AACtE,SAAKC,IAAL,GAAYC,wBAAaC,OAAzB;AACA,SAAKJ,cAAL,GAAsBA,cAAtB;AACA,SAAKC,iBAAL,GAAyBA,iBAAzB;AACD;;;;WAED,kBAAsB;AAEpB,UAAII,KAAK,GAAI,CAAC,KAAKH,IAAL,GAAY,IAAb,KAAsB,CAAnC;AAOA,UAAII,SAAS,GAAG,CAAhB;AACA,UAAIC,YAAJ;;AAGA,UAAI,KAAKN,iBAAT,EAA4B;AAC1BK,QAAAA,SAAS,IAAI,CAAb;AACD;;AAGD,UAAI,KAAKN,cAAL,CAAoBQ,SAAxB,EAAmC;AACjCH,QAAAA,KAAK,IAAI,IAAT;AACD;;AACDA,MAAAA,KAAK,GAAGA,KAAK,IAAK,KAAKL,cAAL,CAAoBS,GAApB,IAA2B,CAA7C;;AACA,UAAI,KAAKT,cAAL,CAAoBU,QAAxB,EAAkC;AAChCL,QAAAA,KAAK,IAAI,IAAT;AACD;;AACDE,MAAAA,YAAY,GAAG,KAAKP,cAAL,CAAoBO,YAAnC;AACA,UAAMI,qBAAqB,GAAG,wBAAa,KAAKX,cAAL,CAAoBY,eAAjC,CAA9B;AACAN,MAAAA,SAAS,IAAIK,qBAAqB,GAAG,CAArC;AACAL,MAAAA,SAAS,IAAIC,YAAY,CAACM,UAA1B;AAKA,UAAMC,GAAG,GAAG,kCAAuBR,SAAvB,CAAZ;AACA,UAAIS,GAAG,GAAGD,GAAG,CAACE,MAAJ,GAAa,CAAvB;AACA,UAAMC,MAAM,GAAG,IAAIC,WAAJ,CAAgBZ,SAAS,GAAGS,GAA5B,CAAf;AACA,UAAMI,UAAU,GAAG,IAAIC,UAAJ,CAAeH,MAAf,CAAnB;AAGAE,MAAAA,UAAU,CAAC,CAAD,CAAV,GAAgBd,KAAhB;AACAc,MAAAA,UAAU,CAACE,GAAX,CAAeP,GAAf,EAAoB,CAApB;AAEAC,MAAAA,GAAG,GAAG,uBAAY,KAAKf,cAAL,CAAoBY,eAAhC,EAAiDD,qBAAjD,EAAwEQ,UAAxE,EAAoFJ,GAApF,CAAN;;AAGA,UAAI,KAAKd,iBAAT,EAA4B;AAC1Bc,QAAAA,GAAG,GAAG,uBAAY,KAAKd,iBAAjB,EAAoCkB,UAApC,EAAgDJ,GAAhD,CAAN;AACD;;AAGDR,MAAAA,YAAY,IAAIY,UAAU,CAACE,GAAX,CAAed,YAAf,EAA6BQ,GAA7B,CAAhB;AAEA,aAAOE,MAAP;AACD","sourcesContent":["/* @flow */\n\nimport { encodeMultiByteInteger, lengthOfUTF8, writeString, writeUint16 } from './util';\nimport { MESSAGE_TYPE } from './constants';\nimport Message from './Message';\n\n/**\n * Construct an MQTT wire protocol message.\n * @param type MQTT packet type.\n * @param options optional wire message attributes.\n *\n * Optional properties\n *\n * messageIdentifier: message ID in the range [0..65535]\n * payloadMessage:  Application Message - PUBLISH only\n * topics:      array of strings (SUBSCRIBE, UNSUBSCRIBE)\n * requestQoS:    array of QoS values [0..2]\n *\n * @private\n * @ignore\n */\nexport default class {\n  type: number;\n  messageIdentifier: ?number = null;\n  payloadMessage: Message;\n  onDispatched: ?() => void;\n  pubRecReceived: ?boolean;\n  sequence: ?number;\n\n  constructor(payloadMessage: Message, messageIdentifier: ?number = null) {\n    this.type = MESSAGE_TYPE.PUBLISH;\n    this.payloadMessage = payloadMessage;\n    this.messageIdentifier = messageIdentifier;\n  }\n\n  encode(): ArrayBuffer {\n    // Compute the first byte of the fixed header\n    let first = ((this.type & 0x0f) << 4);\n\n    /*\n     * Now calculate the length of the variable header + payload by adding up the lengths\n     * of all the component parts\n     */\n\n    let remLength = 0;\n    let payloadBytes: ?Uint8Array;\n\n    // if the message contains a messageIdentifier then we need two bytes for that\n    if (this.messageIdentifier) {\n      remLength += 2;\n    }\n\n    //Publish\n    if (this.payloadMessage.duplicate) {\n      first |= 0x08;\n    }\n    first = first |= (this.payloadMessage.qos << 1);\n    if (this.payloadMessage.retained) {\n      first |= 0x01;\n    }\n    payloadBytes = this.payloadMessage.payloadBytes;\n    const destinationNameLength = lengthOfUTF8(this.payloadMessage.destinationName);\n    remLength += destinationNameLength + 2;\n    remLength += payloadBytes.byteLength;\n    //End publish\n\n    // Now we can allocate a buffer for the message\n\n    const mbi = encodeMultiByteInteger(remLength);  // Convert the length to MQTT MBI format\n    let pos = mbi.length + 1;        // Offset of start of variable header\n    const buffer = new ArrayBuffer(remLength + pos);\n    const byteStream = new Uint8Array(buffer);    // view it as a sequence of bytes\n\n    //Write the fixed header into the buffer\n    byteStream[0] = first;\n    byteStream.set(mbi, 1);\n\n    pos = writeString(this.payloadMessage.destinationName, destinationNameLength, byteStream, pos);\n\n    // Output the messageIdentifier - if there is one\n    if (this.messageIdentifier) {\n      pos = writeUint16(this.messageIdentifier, byteStream, pos);\n    }\n\n    // PUBLISH has a text or binary payload, if text do not add a 2 byte length field, just the UTF characters.\n    payloadBytes && byteStream.set(payloadBytes, pos);\n\n    return buffer;\n  }\n}\n"]},"metadata":{},"sourceType":"script"}
{"ast":null,"code":"var _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _classCallCheck2 = _interopRequireDefault(require(\"@babel/runtime/helpers/classCallCheck\"));\n\nvar _createClass2 = _interopRequireDefault(require(\"@babel/runtime/helpers/createClass\"));\n\nvar _util = require(\"./util\");\n\nvar _constants = require(\"./constants\");\n\nvar _default = function () {\n  function _default(type) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    (0, _classCallCheck2.default)(this, _default);\n    this.messageIdentifier = null;\n    this.type = type;\n    var self = this;\n    Object.keys(options).forEach(function (name) {\n      self[name] = options[name];\n    });\n  }\n\n  (0, _createClass2.default)(_default, [{\n    key: \"encode\",\n    value: function encode() {\n      var first = (this.type & 0x0f) << 4;\n      var remLength = 0;\n      var topicStrLength = [];\n\n      if (this.messageIdentifier) {\n        remLength += 2;\n      }\n\n      switch (this.type) {\n        case _constants.MESSAGE_TYPE.SUBSCRIBE:\n          first |= 0x02;\n\n          if (!this.topics) {\n            throw new Error((0, _util.format)(_constants.ERROR.INVALID_STATE, ['SUBSCRIBE WireMessage with no topics']));\n          }\n\n          if (!this.requestedQos) {\n            throw new Error((0, _util.format)(_constants.ERROR.INVALID_STATE, ['SUBSCRIBE WireMessage with no requestedQos']));\n          }\n\n          for (var i = 0; i < this.topics.length; i++) {\n            topicStrLength[i] = (0, _util.lengthOfUTF8)(this.topics[i]);\n            remLength += topicStrLength[i] + 2;\n          }\n\n          remLength += this.requestedQos.length;\n          break;\n\n        case _constants.MESSAGE_TYPE.UNSUBSCRIBE:\n          first |= 0x02;\n\n          if (!this.topics) {\n            throw new Error((0, _util.format)(_constants.ERROR.INVALID_STATE, ['UNSUBSCRIBE WireMessage with no topics']));\n          }\n\n          for (var _i = 0; _i < this.topics.length; _i++) {\n            topicStrLength[_i] = (0, _util.lengthOfUTF8)(this.topics[_i]);\n            remLength += topicStrLength[_i] + 2;\n          }\n\n          break;\n\n        case _constants.MESSAGE_TYPE.PUBREL:\n          first |= 0x02;\n          break;\n\n        case _constants.MESSAGE_TYPE.DISCONNECT:\n          break;\n\n        default:\n      }\n\n      var mbi = (0, _util.encodeMultiByteInteger)(remLength);\n      var pos = mbi.length + 1;\n      var buffer = new ArrayBuffer(remLength + pos);\n      var byteStream = new Uint8Array(buffer);\n      byteStream[0] = first;\n      byteStream.set(mbi, 1);\n\n      if (this.messageIdentifier) {\n        pos = (0, _util.writeUint16)(this.messageIdentifier, byteStream, pos);\n      }\n\n      switch (this.type) {\n        case _constants.MESSAGE_TYPE.SUBSCRIBE:\n          if (!this.topics) {\n            throw new Error((0, _util.format)(_constants.ERROR.INVALID_STATE, ['SUBSCRIBE WireMessage with no topics']));\n          }\n\n          for (var _i2 = 0; _i2 < this.topics.length; _i2++) {\n            pos = (0, _util.writeString)(this.topics[_i2], topicStrLength[_i2], byteStream, pos);\n\n            if (!this.requestedQos || typeof this.requestedQos[_i2] === 'undefined') {\n              throw new Error((0, _util.format)(_constants.ERROR.INVALID_STATE, ['SUBSCRIBE WireMessage topic with no corresponding requestedQos']));\n            }\n\n            byteStream[pos++] = this.requestedQos[_i2];\n          }\n\n          break;\n\n        case _constants.MESSAGE_TYPE.UNSUBSCRIBE:\n          if (!this.topics) {\n            throw new Error((0, _util.format)(_constants.ERROR.INVALID_STATE, ['UNSUBSCRIBE WireMessage with no topics']));\n          }\n\n          for (var _i3 = 0; _i3 < this.topics.length; _i3++) {\n            pos = (0, _util.writeString)(this.topics[_i3], topicStrLength[_i3], byteStream, pos);\n          }\n\n          break;\n\n        default:\n      }\n\n      return buffer;\n    }\n  }]);\n  return _default;\n}();\n\nexports.default = _default;","map":{"version":3,"sources":["C:/Users/venkatesh.devireddy/Projects/IoT_Central_CPM/node_modules/react-native-azure-iotcentral-client/node_modules/react-native-paho-mqtt/src/WireMessage.js"],"names":["type","options","messageIdentifier","self","Object","keys","forEach","name","first","remLength","topicStrLength","MESSAGE_TYPE","SUBSCRIBE","topics","Error","ERROR","INVALID_STATE","requestedQos","i","length","UNSUBSCRIBE","PUBREL","DISCONNECT","mbi","pos","buffer","ArrayBuffer","byteStream","Uint8Array","set"],"mappings":";;;;;;;;;;;AAEA;;AACA;;;AAoCE,oBAAYA,IAAZ,EAKQ;AAAA,QALkBC,OAKlB,uEAAJ,EAAI;AAAA;AAAA,SAvBRC,iBAuBQ,GAvBqB,IAuBrB;AACN,SAAKF,IAAL,GAAYA,IAAZ;AACA,QAAMG,IAAY,GAAG,IAArB;AACAC,IAAAA,MAAM,CAACC,IAAP,CAAYJ,OAAZ,EAAqBK,OAArB,CAA6B,UAACC,IAAD,EAAU;AACrCJ,MAAAA,IAAI,CAACI,IAAD,CAAJ,GAAaN,OAAO,CAACM,IAAD,CAApB;AACD,KAFD;AAGD;;;;WAED,kBAAsB;AAEpB,UAAIC,KAAK,GAAI,CAAC,KAAKR,IAAL,GAAY,IAAb,KAAsB,CAAnC;AAOA,UAAIS,SAAS,GAAG,CAAhB;AACA,UAAMC,cAAc,GAAG,EAAvB;;AAGA,UAAI,KAAKR,iBAAT,EAA4B;AAC1BO,QAAAA,SAAS,IAAI,CAAb;AACD;;AAED,cAAQ,KAAKT,IAAb;AAEE,aAAKW,wBAAaC,SAAlB;AACEJ,UAAAA,KAAK,IAAI,IAAT;;AACA,cAAI,CAAC,KAAKK,MAAV,EAAkB;AAChB,kBAAM,IAAIC,KAAJ,CAAU,kBAAOC,iBAAMC,aAAb,EAA4B,CAAC,sCAAD,CAA5B,CAAV,CAAN;AACD;;AACD,cAAI,CAAC,KAAKC,YAAV,EAAwB;AACtB,kBAAM,IAAIH,KAAJ,CAAU,kBAAOC,iBAAMC,aAAb,EAA4B,CAAC,4CAAD,CAA5B,CAAV,CAAN;AACD;;AACD,eAAK,IAAIE,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAG,KAAKL,MAAL,CAAYM,MAAhC,EAAwCD,CAAC,EAAzC,EAA6C;AAC3CR,YAAAA,cAAc,CAACQ,CAAD,CAAd,GAAoB,wBAAa,KAAKL,MAAL,CAAYK,CAAZ,CAAb,CAApB;AACAT,YAAAA,SAAS,IAAIC,cAAc,CAACQ,CAAD,CAAd,GAAoB,CAAjC;AACD;;AACDT,UAAAA,SAAS,IAAI,KAAKQ,YAAL,CAAkBE,MAA/B;AAEA;;AAEF,aAAKR,wBAAaS,WAAlB;AACEZ,UAAAA,KAAK,IAAI,IAAT;;AACA,cAAI,CAAC,KAAKK,MAAV,EAAkB;AAChB,kBAAM,IAAIC,KAAJ,CAAU,kBAAOC,iBAAMC,aAAb,EAA4B,CAAC,wCAAD,CAA5B,CAAV,CAAN;AACD;;AACD,eAAK,IAAIE,EAAC,GAAG,CAAb,EAAgBA,EAAC,GAAG,KAAKL,MAAL,CAAYM,MAAhC,EAAwCD,EAAC,EAAzC,EAA6C;AAC3CR,YAAAA,cAAc,CAACQ,EAAD,CAAd,GAAoB,wBAAa,KAAKL,MAAL,CAAYK,EAAZ,CAAb,CAApB;AACAT,YAAAA,SAAS,IAAIC,cAAc,CAACQ,EAAD,CAAd,GAAoB,CAAjC;AACD;;AACD;;AAEF,aAAKP,wBAAaU,MAAlB;AACEb,UAAAA,KAAK,IAAI,IAAT;AACA;;AAEF,aAAKG,wBAAaW,UAAlB;AACE;;AAEF;AApCF;;AAyCA,UAAMC,GAAG,GAAG,kCAAuBd,SAAvB,CAAZ;AACA,UAAIe,GAAG,GAAGD,GAAG,CAACJ,MAAJ,GAAa,CAAvB;AACA,UAAMM,MAAM,GAAG,IAAIC,WAAJ,CAAgBjB,SAAS,GAAGe,GAA5B,CAAf;AACA,UAAMG,UAAU,GAAG,IAAIC,UAAJ,CAAeH,MAAf,CAAnB;AAGAE,MAAAA,UAAU,CAAC,CAAD,CAAV,GAAgBnB,KAAhB;AACAmB,MAAAA,UAAU,CAACE,GAAX,CAAeN,GAAf,EAAoB,CAApB;;AAGA,UAAI,KAAKrB,iBAAT,EAA4B;AAC1BsB,QAAAA,GAAG,GAAG,uBAAY,KAAKtB,iBAAjB,EAAoCyB,UAApC,EAAgDH,GAAhD,CAAN;AACD;;AAED,cAAQ,KAAKxB,IAAb;AACE,aAAKW,wBAAaC,SAAlB;AACE,cAAI,CAAC,KAAKC,MAAV,EAAkB;AAChB,kBAAM,IAAIC,KAAJ,CAAU,kBAAOC,iBAAMC,aAAb,EAA4B,CAAC,sCAAD,CAA5B,CAAV,CAAN;AACD;;AAED,eAAK,IAAIE,GAAC,GAAG,CAAb,EAAgBA,GAAC,GAAG,KAAKL,MAAL,CAAYM,MAAhC,EAAwCD,GAAC,EAAzC,EAA6C;AAC3CM,YAAAA,GAAG,GAAG,uBAAY,KAAKX,MAAL,CAAYK,GAAZ,CAAZ,EAA4BR,cAAc,CAACQ,GAAD,CAA1C,EAA+CS,UAA/C,EAA2DH,GAA3D,CAAN;;AACA,gBAAI,CAAC,KAAKP,YAAN,IAAsB,OAAO,KAAKA,YAAL,CAAkBC,GAAlB,CAAP,KAAgC,WAA1D,EAAuE;AACrE,oBAAM,IAAIJ,KAAJ,CAAU,kBAAOC,iBAAMC,aAAb,EAA4B,CAAC,gEAAD,CAA5B,CAAV,CAAN;AACD;;AACDW,YAAAA,UAAU,CAACH,GAAG,EAAJ,CAAV,GAAoB,KAAKP,YAAL,CAAkBC,GAAlB,CAApB;AACD;;AACD;;AAEF,aAAKP,wBAAaS,WAAlB;AACE,cAAI,CAAC,KAAKP,MAAV,EAAkB;AAChB,kBAAM,IAAIC,KAAJ,CAAU,kBAAOC,iBAAMC,aAAb,EAA4B,CAAC,wCAAD,CAA5B,CAAV,CAAN;AACD;;AAED,eAAK,IAAIE,GAAC,GAAG,CAAb,EAAgBA,GAAC,GAAG,KAAKL,MAAL,CAAYM,MAAhC,EAAwCD,GAAC,EAAzC,EAA6C;AAC3CM,YAAAA,GAAG,GAAG,uBAAY,KAAKX,MAAL,CAAYK,GAAZ,CAAZ,EAA4BR,cAAc,CAACQ,GAAD,CAA1C,EAA+CS,UAA/C,EAA2DH,GAA3D,CAAN;AACD;;AACD;;AAEF;AAzBF;;AA6BA,aAAOC,MAAP;AACD","sourcesContent":["/* @flow */\n\nimport { encodeMultiByteInteger, format, lengthOfUTF8, writeString, writeUint16 } from './util';\nimport { ERROR, MESSAGE_TYPE } from './constants';\n\n/**\n * Construct an MQTT wire protocol message.\n * @param type MQTT packet type.\n * @param options optional wire message attributes.\n *\n * Optional properties\n *\n * messageIdentifier: message ID in the range [0..65535]\n * topics:      array of strings (SUBSCRIBE, UNSUBSCRIBE)\n * requestQoS:    array of QoS values [0..2]\n *\n * @private\n * @ignore\n */\nexport default class {\n  type: number;\n  messageIdentifier: ?number = null;\n  clientId: ?string;\n\n  //CONNACK only\n  returnCode: ?(number | Uint8Array);\n  sessionPresent: ?boolean;\n  onDispatched: ?() => void;\n\n  //PUB/SUB flows only\n  subAckReceived: ?(grantedQos: number) => void;\n  onFailure: ?(Error) => void;\n  timeOut: ?number;\n  unSubAckReceived: ?() => void;\n  topics: ?string[];\n  requestedQos: ?(0 | 1 | 2)[];\n\n  sequence: ?number;\n\n  constructor(type: number, options: {\n    messageIdentifier?: number;\n    topics?: string[];\n    requestedQos?: (0 | 1 | 2)[];\n    clientId?: string\n  } = {}) {\n    this.type = type;\n    const self: Object = this;\n    Object.keys(options).forEach((name) => {\n      self[name] = options[name];\n    });\n  }\n\n  encode(): ArrayBuffer {\n    // Compute the first byte of the fixed header\n    let first = ((this.type & 0x0f) << 4);\n\n    /*\n     * Now calculate the length of the variable header + payload by adding up the lengths\n     * of all the component parts\n     */\n\n    let remLength = 0;\n    const topicStrLength = [];\n\n    // if the message contains a messageIdentifier then we need two bytes for that\n    if (this.messageIdentifier) {\n      remLength += 2;\n    }\n\n    switch (this.type) {\n      // Subscribe, Unsubscribe can both contain topic strings\n      case MESSAGE_TYPE.SUBSCRIBE:\n        first |= 0x02; // Qos = 1;\n        if (!this.topics) {\n          throw new Error(format(ERROR.INVALID_STATE, ['SUBSCRIBE WireMessage with no topics']));\n        }\n        if (!this.requestedQos) {\n          throw new Error(format(ERROR.INVALID_STATE, ['SUBSCRIBE WireMessage with no requestedQos']));\n        }\n        for (let i = 0; i < this.topics.length; i++) {\n          topicStrLength[i] = lengthOfUTF8(this.topics[i]);\n          remLength += topicStrLength[i] + 2;\n        }\n        remLength += this.requestedQos.length; // 1 byte for each topic's Qos\n        // QoS on Subscribe only\n        break;\n\n      case MESSAGE_TYPE.UNSUBSCRIBE:\n        first |= 0x02; // Qos = 1;\n        if (!this.topics) {\n          throw new Error(format(ERROR.INVALID_STATE, ['UNSUBSCRIBE WireMessage with no topics']));\n        }\n        for (let i = 0; i < this.topics.length; i++) {\n          topicStrLength[i] = lengthOfUTF8(this.topics[i]);\n          remLength += topicStrLength[i] + 2;\n        }\n        break;\n\n      case MESSAGE_TYPE.PUBREL:\n        first |= 0x02; // Qos = 1;\n        break;\n\n      case MESSAGE_TYPE.DISCONNECT:\n        break;\n\n      default:\n    }\n\n    // Now we can allocate a buffer for the message\n\n    const mbi = encodeMultiByteInteger(remLength);  // Convert the length to MQTT MBI format\n    let pos = mbi.length + 1;        // Offset of start of variable header\n    const buffer = new ArrayBuffer(remLength + pos);\n    const byteStream = new Uint8Array(buffer);    // view it as a sequence of bytes\n\n    //Write the fixed header into the buffer\n    byteStream[0] = first;\n    byteStream.set(mbi, 1);\n\n    // Output the messageIdentifier - if there is one\n    if (this.messageIdentifier) {\n      pos = writeUint16(this.messageIdentifier, byteStream, pos);\n    }\n\n    switch (this.type) {\n      case MESSAGE_TYPE.SUBSCRIBE:\n        if (!this.topics) {\n          throw new Error(format(ERROR.INVALID_STATE, ['SUBSCRIBE WireMessage with no topics']));\n        }\n        // SUBSCRIBE has a list of topic strings and request QoS\n        for (let i = 0; i < this.topics.length; i++) {\n          pos = writeString(this.topics[i], topicStrLength[i], byteStream, pos);\n          if (!this.requestedQos || typeof this.requestedQos[i] === 'undefined') {\n            throw new Error(format(ERROR.INVALID_STATE, ['SUBSCRIBE WireMessage topic with no corresponding requestedQos']));\n          }\n          byteStream[pos++] = this.requestedQos[i];\n        }\n        break;\n\n      case MESSAGE_TYPE.UNSUBSCRIBE:\n        if (!this.topics) {\n          throw new Error(format(ERROR.INVALID_STATE, ['UNSUBSCRIBE WireMessage with no topics']));\n        }\n        // UNSUBSCRIBE has a list of topic strings\n        for (let i = 0; i < this.topics.length; i++) {\n          pos = writeString(this.topics[i], topicStrLength[i], byteStream, pos);\n        }\n        break;\n\n      default:\n      // Do nothing.\n    }\n\n    return buffer;\n  }\n}\n"]},"metadata":{},"sourceType":"script"}
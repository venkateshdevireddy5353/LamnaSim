{"ast":null,"code":"var _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.yAxisIface = exports.xAxisIface = exports.axisIface = void 0;\n\nvar _defineProperty2 = _interopRequireDefault(require(\"@babel/runtime/helpers/defineProperty\"));\n\nvar _propTypes = _interopRequireDefault(require(\"prop-types\"));\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { (0, _defineProperty2.default)(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nvar axisIface = {\n  enabled: _propTypes.default.bool,\n  drawLabels: _propTypes.default.bool,\n  drawAxisLine: _propTypes.default.bool,\n  drawGridLines: _propTypes.default.bool,\n  textColor: _propTypes.default.number,\n  textSize: _propTypes.default.number,\n  fontFamily: _propTypes.default.string,\n  fontStyle: _propTypes.default.string,\n  fontWeight: _propTypes.default.string,\n  gridColor: _propTypes.default.number,\n  gridLineWidth: _propTypes.default.number,\n  axisLineColor: _propTypes.default.number,\n  axisLineWidth: _propTypes.default.number,\n  gridDashedLine: _propTypes.default.shape({\n    lineLength: _propTypes.default.number,\n    spaceLength: _propTypes.default.number,\n    phase: _propTypes.default.number\n  }),\n  limitLines: _propTypes.default.arrayOf(_propTypes.default.shape({\n    limit: _propTypes.default.number.isRequired,\n    label: _propTypes.default.string,\n    lineColor: _propTypes.default.number,\n    lineWidth: _propTypes.default.number,\n    valueTextColor: _propTypes.default.number,\n    valueFont: _propTypes.default.number,\n    labelPosition: _propTypes.default.oneOf(['LEFT_TOP', 'LEFT_BOTTOM', 'RIGHT_TOP', 'RIGHT_BOTTOM']),\n    lineDashPhase: _propTypes.default.number,\n    lineDashLengths: _propTypes.default.arrayOf(_propTypes.default.number)\n  })),\n  drawLimitLinesBehindData: _propTypes.default.bool,\n  axisMaximum: _propTypes.default.number,\n  axisMinimum: _propTypes.default.number,\n  granularity: _propTypes.default.number,\n  granularityEnabled: _propTypes.default.bool,\n  labelCount: _propTypes.default.number,\n  labelCountForce: _propTypes.default.bool,\n  centerAxisLabels: _propTypes.default.bool,\n  valueFormatter: _propTypes.default.oneOfType([_propTypes.default.oneOf(['largeValue', 'percent', 'date']), _propTypes.default.string, _propTypes.default.arrayOf(_propTypes.default.string)]),\n  valueFormatterPattern: _propTypes.default.string,\n  since: _propTypes.default.number,\n  timeUnit: _propTypes.default.oneOf(['MILLISECONDS', 'SECONDS', 'MINUTES', 'HOURS', 'DAYS'])\n};\nexports.axisIface = axisIface;\n\nvar xAxisIface = _objectSpread(_objectSpread({}, axisIface), {}, {\n  labelRotationAngle: _propTypes.default.number,\n  avoidFirstLastClipping: _propTypes.default.bool,\n  position: _propTypes.default.oneOf(['TOP', 'BOTTOM', 'BOTH_SIDED', 'TOP_INSIDE', 'BOTTOM_INSIDE']),\n  yOffset: _propTypes.default.number\n});\n\nexports.xAxisIface = xAxisIface;\n\nvar yAxisIface = _objectSpread(_objectSpread({}, axisIface), {}, {\n  inverted: _propTypes.default.bool,\n  spaceTop: _propTypes.default.number,\n  spaceBottom: _propTypes.default.number,\n  position: _propTypes.default.oneOf(['OUTSIDE_CHART', 'INSIDE_CHART']),\n  maxWidth: _propTypes.default.number,\n  minWidth: _propTypes.default.number,\n  zeroLine: _propTypes.default.shape({\n    enabled: _propTypes.default.bool,\n    lineWidth: _propTypes.default.number,\n    lineColor: _propTypes.default.number\n  })\n});\n\nexports.yAxisIface = yAxisIface;","map":{"version":3,"sources":["C:/Users/venkatesh.devireddy/Projects/IoT_Central_CPM/node_modules/react-native-charts-wrapper/lib/AxisIface.js"],"names":["axisIface","enabled","PropTypes","bool","drawLabels","drawAxisLine","drawGridLines","textColor","number","textSize","fontFamily","string","fontStyle","fontWeight","gridColor","gridLineWidth","axisLineColor","axisLineWidth","gridDashedLine","shape","lineLength","spaceLength","phase","limitLines","arrayOf","limit","isRequired","label","lineColor","lineWidth","valueTextColor","valueFont","labelPosition","oneOf","lineDashPhase","lineDashLengths","drawLimitLinesBehindData","axisMaximum","axisMinimum","granularity","granularityEnabled","labelCount","labelCountForce","centerAxisLabels","valueFormatter","oneOfType","valueFormatterPattern","since","timeUnit","xAxisIface","labelRotationAngle","avoidFirstLastClipping","position","yOffset","yAxisIface","inverted","spaceTop","spaceBottom","maxWidth","minWidth","zeroLine"],"mappings":"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","sourcesContent":["import PropTypes from 'prop-types';\n\nexport const axisIface = {\n  // what is drawn\n  enabled: PropTypes.bool,\n  drawLabels: PropTypes.bool,\n  drawAxisLine: PropTypes.bool,\n  drawGridLines: PropTypes.bool,\n\n  // style\n  textColor: PropTypes.number,\n  textSize: PropTypes.number,\n  fontFamily: PropTypes.string,\n  fontStyle: PropTypes.string,\n  fontWeight: PropTypes.string,\n  gridColor: PropTypes.number,\n  gridLineWidth: PropTypes.number,\n  axisLineColor: PropTypes.number,\n  axisLineWidth: PropTypes.number,\n  gridDashedLine: PropTypes.shape({\n    lineLength: PropTypes.number,\n    spaceLength: PropTypes.number,\n    phase: PropTypes.number\n  }),\n\n  // limit lines\n  limitLines: PropTypes.arrayOf(\n    PropTypes.shape({\n      limit: PropTypes.number.isRequired,\n      label: PropTypes.string,\n      lineColor: PropTypes.number,\n      lineWidth: PropTypes.number,\n      valueTextColor: PropTypes.number,\n      valueFont: PropTypes.number,\n      labelPosition: PropTypes.oneOf(['LEFT_TOP', 'LEFT_BOTTOM', 'RIGHT_TOP', 'RIGHT_BOTTOM']),\n      lineDashPhase: PropTypes.number,\n      lineDashLengths: PropTypes.arrayOf(PropTypes.number)\n    })\n  ),\n  drawLimitLinesBehindData: PropTypes.bool,\n\n  axisMaximum: PropTypes.number,\n  axisMinimum: PropTypes.number,\n  granularity: PropTypes.number,\n  granularityEnabled: PropTypes.bool,\n\n  labelCount: PropTypes.number,\n  labelCountForce: PropTypes.bool,\n\n  centerAxisLabels: PropTypes.bool, // Centers the axis labels instead of drawing them at their original position. This is useful especially for grouped BarChart.\n\n  // formatting\n  valueFormatter: PropTypes.oneOfType([\n    PropTypes.oneOf(['largeValue', 'percent', 'date']),\n    PropTypes.string,\n    PropTypes.arrayOf(PropTypes.string)\n  ]),\n\n  // valueFormatterPattern, since, timeUnit are used when valueFormatter is 'date'\n  // since: milliseconds of 2018-6-1, timeUnit: DAYS, x:9, valueFormatterPattern: YYYY-MM-dd\n  // will display 2018-6-10\n\n  // Note: for iOS/Charts, double is used for x, but in MpAndroidChart, float is used for x.\n  // so in android, there will be precision loss when you use MILLISECONDS/SECOND/MINUTES as x value.   \n  // you can use a different since like seconds of 2019 or use timeUnit DAYS, then x value will be within a valid range.\n\n  valueFormatterPattern: PropTypes.string,\n  since: PropTypes.number, // milliseconds from 1970-1-1 when x=0\n  timeUnit: PropTypes.oneOf(['MILLISECONDS', 'SECONDS', 'MINUTES', 'HOURS', 'DAYS']), // timeUnit of x,\n};\n\nexport const xAxisIface = {\n  ...axisIface,\n\n  labelRotationAngle: PropTypes.number,\n  avoidFirstLastClipping: PropTypes.bool,\n  position: PropTypes.oneOf(['TOP', 'BOTTOM', 'BOTH_SIDED', 'TOP_INSIDE', 'BOTTOM_INSIDE']),\n  yOffset: PropTypes.number\n};\n\nexport const yAxisIface = {\n  ...axisIface,\n\n  inverted: PropTypes.bool,\n  spaceTop: PropTypes.number,\n  spaceBottom: PropTypes.number,\n\n  position: PropTypes.oneOf(['OUTSIDE_CHART', 'INSIDE_CHART']),\n\n  maxWidth: PropTypes.number,\n  minWidth: PropTypes.number,\n\n  // zero line\n  zeroLine: PropTypes.shape({\n    enabled: PropTypes.bool,\n    lineWidth: PropTypes.number,\n    lineColor: PropTypes.number\n  })\n};\n"]},"metadata":{},"sourceType":"script"}
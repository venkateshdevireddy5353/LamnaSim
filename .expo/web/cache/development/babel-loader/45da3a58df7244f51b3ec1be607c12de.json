{"ast":null,"code":"var _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _classCallCheck2 = _interopRequireDefault(require(\"@babel/runtime/helpers/classCallCheck\"));\n\nvar _createClass2 = _interopRequireDefault(require(\"@babel/runtime/helpers/createClass\"));\n\nvar _inherits2 = _interopRequireDefault(require(\"@babel/runtime/helpers/inherits\"));\n\nvar _possibleConstructorReturn2 = _interopRequireDefault(require(\"@babel/runtime/helpers/possibleConstructorReturn\"));\n\nvar _getPrototypeOf2 = _interopRequireDefault(require(\"@babel/runtime/helpers/getPrototypeOf\"));\n\nvar _ClientImplementation = _interopRequireDefault(require(\"./ClientImplementation\"));\n\nvar _Message = _interopRequireDefault(require(\"./Message\"));\n\nvar _util = require(\"./util\");\n\nvar _constants = require(\"./constants\");\n\nvar _events = _interopRequireDefault(require(\"events\"));\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2.default)(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2.default)(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2.default)(this, result); }; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\n\nvar Client = function (_EventEmitter) {\n  (0, _inherits2.default)(Client, _EventEmitter);\n\n  var _super = _createSuper(Client);\n\n  function Client(_ref) {\n    var _this;\n\n    var uri = _ref.uri,\n        clientId = _ref.clientId,\n        storage = _ref.storage,\n        webSocket = _ref.webSocket;\n    (0, _classCallCheck2.default)(this, Client);\n    _this = _super.call(this);\n\n    if (!/^(wss?):\\/\\/((\\[(.+)\\])|([^\\/]+?))(:(\\d+))?(\\/.*)$/.test(uri)) {\n      throw new Error((0, _util.format)(_constants.ERROR.INVALID_ARGUMENT, [typeof uri, 'uri']));\n    }\n\n    var clientIdLength = 0;\n\n    for (var i = 0; i < clientId.length; i++) {\n      var charCode = clientId.charCodeAt(i);\n\n      if (charCode >= 0xD800 && charCode <= 0xDBFF) {\n        i++;\n      }\n\n      clientIdLength++;\n    }\n\n    if (typeof clientId !== 'string' || clientIdLength > 65535) {\n      throw new Error((0, _util.format)(_constants.ERROR.INVALID_ARGUMENT, [clientId, 'clientId']));\n    }\n\n    _this._client = new _ClientImplementation.default(uri, clientId, storage, webSocket);\n\n    _this._client.onMessageDelivered = function (message) {\n      return _this.emit('messageDelivered', message);\n    };\n\n    _this._client.onMessageArrived = function (message) {\n      return _this.emit('messageReceived', message);\n    };\n\n    _this._client.onConnectionLost = function (e) {\n      return _this.emit('connectionLost', e);\n    };\n\n    return _this;\n  }\n\n  (0, _createClass2.default)(Client, [{\n    key: \"connect\",\n    value: function connect() {\n      var _this2 = this;\n\n      var _ref2 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n          userName = _ref2.userName,\n          password = _ref2.password,\n          willMessage = _ref2.willMessage,\n          _ref2$timeout = _ref2.timeout,\n          timeout = _ref2$timeout === void 0 ? 30000 : _ref2$timeout,\n          _ref2$keepAliveInterv = _ref2.keepAliveInterval,\n          keepAliveInterval = _ref2$keepAliveInterv === void 0 ? _constants.DEFAULT_KEEPALIVE_SECONDS : _ref2$keepAliveInterv,\n          _ref2$cleanSession = _ref2.cleanSession,\n          cleanSession = _ref2$cleanSession === void 0 ? true : _ref2$cleanSession,\n          _ref2$mqttVersion = _ref2.mqttVersion,\n          mqttVersion = _ref2$mqttVersion === void 0 ? 4 : _ref2$mqttVersion,\n          _ref2$delay = _ref2.delay,\n          delay = _ref2$delay === void 0 ? 0 : _ref2$delay;\n\n      (0, _util.validate)({\n        userName: userName,\n        password: password,\n        willMessage: willMessage,\n        timeout: timeout,\n        keepAliveInterval: keepAliveInterval,\n        cleanSession: cleanSession,\n        mqttVersion: mqttVersion\n      }, {\n        timeout: 'number',\n        userName: '?string',\n        password: '?string',\n        willMessage: '?object',\n        keepAliveInterval: 'number',\n        cleanSession: 'boolean',\n        mqttVersion: 'number',\n        delay: 'number'\n      });\n      return new Promise(function (resolve, reject) {\n        if (mqttVersion > 4 || mqttVersion < 3) {\n          throw new Error((0, _util.format)(_constants.ERROR.INVALID_ARGUMENT, [mqttVersion, 'mqttVersion']));\n        }\n\n        if (password !== undefined && userName === undefined) {\n          throw new Error((0, _util.format)(_constants.ERROR.INVALID_ARGUMENT, [password, 'password']));\n        }\n\n        if (willMessage) {\n          if (!(willMessage instanceof _Message.default)) {\n            throw new Error((0, _util.format)(_constants.ERROR.INVALID_TYPE, [willMessage, 'willMessage']));\n          }\n\n          willMessage.payloadString;\n\n          if (typeof willMessage.destinationName === 'undefined') {\n            throw new Error((0, _util.format)(_constants.ERROR.INVALID_TYPE, [typeof willMessage.destinationName, 'willMessage.destinationName']));\n          }\n        }\n\n        _this2._client.connect({\n          userName: userName,\n          password: password,\n          willMessage: willMessage || null,\n          timeout: timeout,\n          keepAliveInterval: keepAliveInterval,\n          cleanSession: cleanSession,\n          delay: delay,\n          mqttVersion: mqttVersion === 4 ? 4 : 3,\n          onSuccess: resolve,\n          onFailure: reject\n        });\n      });\n    }\n  }, {\n    key: \"subscribe\",\n    value: function subscribe(filter) {\n      var _this3 = this;\n\n      var _ref3 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},\n          _ref3$qos = _ref3.qos,\n          qos = _ref3$qos === void 0 ? 0 : _ref3$qos,\n          _ref3$timeout = _ref3.timeout,\n          timeout = _ref3$timeout === void 0 ? 30000 : _ref3$timeout;\n\n      return new Promise(function (resolve, reject) {\n        if (typeof filter !== 'string') {\n          throw new Error('Invalid argument:' + filter);\n        }\n\n        if (typeof timeout !== 'number') {\n          throw new Error('Invalid argument:' + timeout);\n        }\n\n        if ([0, 1, 2].indexOf(qos) === -1) {\n          throw new Error('Invalid argument:' + qos);\n        }\n\n        _this3._client.subscribe(filter, {\n          timeout: timeout,\n          qos: qos,\n          onSuccess: resolve,\n          onFailure: reject\n        });\n      });\n    }\n  }, {\n    key: \"unsubscribe\",\n    value: function unsubscribe(filter) {\n      var _this4 = this;\n\n      var _ref4 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},\n          _ref4$timeout = _ref4.timeout,\n          timeout = _ref4$timeout === void 0 ? 30000 : _ref4$timeout;\n\n      return new Promise(function (resolve, reject) {\n        if (typeof filter !== 'string') {\n          throw new Error('Invalid argument:' + filter);\n        }\n\n        if (typeof timeout !== 'number') {\n          throw new Error('Invalid argument:' + timeout);\n        }\n\n        _this4._client.unsubscribe(filter, {\n          timeout: timeout,\n          onSuccess: resolve,\n          onFailure: reject\n        });\n      });\n    }\n  }, {\n    key: \"send\",\n    value: function send(topic, payload, qos, retained) {\n      var message;\n\n      if (arguments.length === 0) {\n        throw new Error('Invalid argument.' + 'length');\n      } else if (arguments.length === 1) {\n        if (!(topic instanceof _Message.default)) {\n          throw new Error('Invalid argument:' + typeof topic);\n        }\n\n        message = topic;\n\n        if (typeof message.destinationName === 'undefined') {\n          throw new Error((0, _util.format)(_constants.ERROR.INVALID_ARGUMENT, [message.destinationName, 'Message.destinationName']));\n        }\n\n        this._client.send(message);\n      } else if (typeof topic === 'string') {\n        message = new _Message.default(payload);\n        message.destinationName = topic;\n\n        if (arguments.length >= 3) {\n          message.qos = qos;\n        }\n\n        if (arguments.length >= 4) {\n          message.retained = retained;\n        }\n\n        this._client.send(message);\n      }\n    }\n  }, {\n    key: \"disconnect\",\n    value: function disconnect() {\n      var _this5 = this;\n\n      return new Promise(function (resolve, reject) {\n        _this5.once('connectionLost', function (error) {\n          if (error && error.errorCode !== 0) {\n            return reject(error);\n          }\n\n          resolve();\n        });\n\n        _this5._client.disconnect();\n      });\n    }\n  }, {\n    key: \"getTraceLog\",\n    value: function getTraceLog() {\n      return this._client.getTraceLog();\n    }\n  }, {\n    key: \"startTrace\",\n    value: function startTrace() {\n      this._client.startTrace();\n    }\n  }, {\n    key: \"stopTrace\",\n    value: function stopTrace() {\n      this._client.stopTrace();\n    }\n  }, {\n    key: \"isConnected\",\n    value: function isConnected() {\n      return this._client.connected;\n    }\n  }, {\n    key: \"uri\",\n    get: function get() {\n      return this._client.uri;\n    }\n  }, {\n    key: \"clientId\",\n    get: function get() {\n      return this._client.clientId;\n    }\n  }, {\n    key: \"trace\",\n    get: function get() {\n      return this._client.traceFunction;\n    },\n    set: function set(trace) {\n      if (typeof trace === 'function') {\n        this._client.traceFunction = trace;\n      } else {\n        throw new Error((0, _util.format)(_constants.ERROR.INVALID_TYPE, [typeof trace, 'onTrace']));\n      }\n    }\n  }]);\n  return Client;\n}(_events.default);\n\nexports.default = Client;","map":{"version":3,"sources":["C:/Users/venkatesh.devireddy/Projects/IoT_Central_CPM/node_modules/react-native-azure-iotcentral-client/node_modules/react-native-paho-mqtt/src/Client.js"],"names":["Client","uri","clientId","storage","webSocket","test","Error","ERROR","INVALID_ARGUMENT","clientIdLength","i","length","charCode","charCodeAt","_client","ClientImplementation","onMessageDelivered","message","emit","onMessageArrived","onConnectionLost","e","userName","password","willMessage","timeout","keepAliveInterval","DEFAULT_KEEPALIVE_SECONDS","cleanSession","mqttVersion","delay","Promise","resolve","reject","undefined","Message","INVALID_TYPE","payloadString","destinationName","connect","onSuccess","onFailure","filter","qos","indexOf","subscribe","unsubscribe","topic","payload","retained","arguments","send","once","error","errorCode","disconnect","getTraceLog","startTrace","stopTrace","connected","traceFunction","trace","EventEmitter"],"mappings":"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","sourcesContent":["/*******************************************************************************\n * Copyright (c) 2013 IBM Corp.\n *\n * All rights reserved. This program and the accompanying materials\n * are made available under the terms of the Eclipse Public License v1.0\n * and Eclipse Distribution License v1.0 which accompany this distribution.\n *\n * The Eclipse Public License is available at\n *    http://www.eclipse.org/legal/epl-v10.html\n * and the Eclipse Distribution License is available at\n *   http://www.eclipse.org/org/documents/edl-v10.php.\n *\n * Contributors:\n *    Andrew Banks - initial API and implementation and initial documentation\n *******************************************************************************/\n/* @flow */\nimport ClientImplementation from './ClientImplementation';\nimport Message from './Message';\nimport { format, validate } from './util';\nimport { DEFAULT_KEEPALIVE_SECONDS, ERROR } from './constants';\nimport EventEmitter from 'events';\n\n// ------------------------------------------------------------------------\n// Public API.\n// ------------------------------------------------------------------------\n\ntype ConstructorOptions = {\n  uri: string,\n  clientId: string,\n  storage: any,\n  webSocket?: Class<WebSocket>\n}\n\ntype ConnectOptions = {\n  userName?: string,\n  password?: string,\n  willMessage?: Message,\n  timeout?: number,\n  keepAliveInterval: number,\n  useSSL: boolean,\n  cleanSession: boolean,\n  mqttVersion: number,\n  delay: number,\n  allowMqttVersionFallback: boolean,\n  uris?: string[]\n}\n\n/**\n * The JavaScript application communicates to the server using a {@link Client} object.\n *\n * Most applications will create just one Client object and then call its connect() method,\n * however applications can create more than one Client object if they wish.\n * In this case the combination of uri and clientId attributes must be different for each Client object.\n *\n * @name Client\n *\n * @fires Client#connectionLost\n * @fires Client#messageReceived\n * @fires Client#messageDelivered\n */\nexport default class Client extends EventEmitter {\n\n\n  _client: ClientImplementation;\n\n  /**\n   *\n   * @param {string} [uri] - the address of the messaging server, as a fully qualified WebSocket URI\n   * @param {string} [clientId] - the Messaging client identifier, between 1 and 23 characters in length.\n   * @param {object} [storage] - object implementing getItem, setItem, removeItem in a manner compatible with localStorage\n   * @param {object} [webSocket] - object implementing the W3C websocket spec\n   */\n  constructor({ uri, clientId, storage, webSocket }: ConstructorOptions) {\n    super();\n\n    if (!/^(wss?):\\/\\/((\\[(.+)\\])|([^\\/]+?))(:(\\d+))?(\\/.*)$/.test(uri)) {\n      throw new Error(format(ERROR.INVALID_ARGUMENT, [typeof uri, 'uri']));\n    }\n\n    let clientIdLength = 0;\n    for (let i = 0; i < clientId.length; i++) {\n      let charCode = clientId.charCodeAt(i);\n      if (charCode >= 0xD800 && charCode <= 0xDBFF) {\n        i++; // Surrogate pair.\n      }\n      clientIdLength++;\n    }\n    if (typeof clientId !== 'string' || clientIdLength > 65535) {\n      throw new Error(format(ERROR.INVALID_ARGUMENT, [clientId, 'clientId']));\n    }\n\n    this._client = new ClientImplementation(uri, clientId, storage, webSocket);\n\n    /**\n     * @event Client#messageDelivered\n     * @type {Message}\n     */\n    this._client.onMessageDelivered = (message) => this.emit('messageDelivered', message);\n\n    /**\n     * @event Client#messageReceived\n     * @type {Message}\n     */\n    this._client.onMessageArrived = (message) => this.emit('messageReceived', message);\n\n    /**\n     * @event Client#connectionLost\n     * @type {Error}\n     */\n    this._client.onConnectionLost = (e) => this.emit('connectionLost', e);\n  }\n\n  /**\n   * Connect this Messaging client to its server.\n   *\n   * @name Client#connect\n   * @function\n   * @param {number} [timeout=30000] - Fail if not connected within this time\n   * @param {string} [userName] - Authentication username for this connection.\n   * @param {string} [password] - Authentication password for this connection.\n   * @param {Message} [willMessage] - sent by the server when the client disconnects abnormally.\n   * @param {number} [keepAliveInterval=60] - ping the server every n ms to avoid being disconnected by the remote end.\n   * @param {number} [mqttVersion=4] - protocol version to use (3 or 4).\n   * @param {boolean} [cleanSession=true] - if true the client and server persistent state is deleted on successful connect.\n   */\n  connect({\n    userName,\n    password,\n    willMessage,\n    timeout = 30000,\n    keepAliveInterval = DEFAULT_KEEPALIVE_SECONDS,\n    cleanSession = true,\n    mqttVersion = 4,\n    delay = 0\n  }: ConnectOptions = {}) {\n    validate({\n      userName,\n      password,\n      willMessage,\n      timeout,\n      keepAliveInterval,\n      cleanSession,\n      mqttVersion\n    }, {\n      timeout: 'number',\n      userName: '?string',\n      password: '?string',\n      willMessage: '?object',\n      keepAliveInterval: 'number',\n      cleanSession: 'boolean',\n      mqttVersion: 'number',\n      delay: 'number'\n    });\n\n    return new Promise((resolve, reject) => {\n\n      if (mqttVersion > 4 || mqttVersion < 3) {\n        throw new Error(format(ERROR.INVALID_ARGUMENT, [mqttVersion, 'mqttVersion']));\n      }\n\n      //Check that if password is set, so is username\n      if (password !== undefined && userName === undefined) {\n        throw new Error(format(ERROR.INVALID_ARGUMENT, [password, 'password']));\n      }\n\n      if (willMessage) {\n        if (!(willMessage instanceof Message)) {\n          throw new Error(format(ERROR.INVALID_TYPE, [willMessage, 'willMessage']));\n        }\n        // The will message must have a payload that can be represented as a string.\n        // Cause the willMessage to throw an exception if this is not the case.\n        willMessage.payloadString;\n\n        if (typeof willMessage.destinationName === 'undefined') {\n          throw new Error(format(ERROR.INVALID_TYPE, [typeof willMessage.destinationName, 'willMessage.destinationName']));\n        }\n      }\n\n      this._client.connect({\n        userName,\n        password,\n        willMessage: willMessage || null,\n        timeout,\n        keepAliveInterval,\n        cleanSession,\n        delay,\n        mqttVersion: mqttVersion === 4 ? 4 : 3,\n        onSuccess: resolve,\n        onFailure: reject\n      });\n    });\n  }\n\n  /**\n   * Subscribe for messages, request receipt of a copy of messages sent to the destinations described by the filter.\n   *\n   * @param {string} [filter] the topic to subscribe to\n   * @param {number} [qos=0] - the maximum qos of any publications sent as a result of making this subscription.\n   * @param {number} [timeout=30000] - milliseconds after which the call will fail\n   * @returns {Promise}\n   */\n  subscribe(filter: string, { qos = 0, timeout = 30000 }: { qos: 0 | 1 | 2, timeout: number } = {}) {\n    return new Promise((resolve, reject) => {\n      if (typeof filter !== 'string') {\n        throw new Error('Invalid argument:' + filter);\n      }\n      if (typeof timeout !== 'number') {\n        throw new Error('Invalid argument:' + timeout);\n      }\n      if ([0, 1, 2].indexOf(qos) === -1) {\n        throw new Error('Invalid argument:' + qos);\n      }\n\n      this._client.subscribe(filter, {\n        timeout,\n        qos,\n        onSuccess: resolve,\n        onFailure: reject\n      });\n    });\n  }\n\n  /**\n   * Unsubscribe for messages, stop receiving messages sent to destinations described by the filter.\n   *\n   * @param {string} [filter] the topic to unsubscribe from\n   * @param {number} [timeout=30000] MS after which the promise will be rejected\n   * @returns {Promise}\n   */\n  unsubscribe(filter: string, { timeout = 30000 }: { timeout: number } = {}) {\n    return new Promise((resolve, reject) => {\n      if (typeof filter !== 'string') {\n        throw new Error('Invalid argument:' + filter);\n      }\n      if (typeof timeout !== 'number') {\n        throw new Error('Invalid argument:' + timeout);\n      }\n\n      this._client.unsubscribe(filter, {\n        timeout,\n        onSuccess: resolve,\n        onFailure: reject\n      });\n    });\n  }\n\n  /**\n   * Send a message to the consumers of the destination in the Message.\n   *\n   * @name Client#send\n   * @function\n   * @param {string|Message} topic - <b>mandatory</b> The name of the destination to which the message is to be sent.\n   *             - If it is the only parameter, used as Message object.\n   * @param {String|ArrayBuffer} payload - The message data to be sent.\n   * @param {number} qos The Quality of Service used to deliver the message.\n   *    <dl>\n   *      <dt>0 Best effort (default).\n   *          <dt>1 At least once.\n   *          <dt>2 Exactly once.\n   *    </dl>\n   * @param {Boolean} retained If true, the message is to be retained by the server and delivered\n   *                     to both current and future subscriptions.\n   *                     If false the server only delivers the message to current subscribers, this is the default for new Messages.\n   *                     A received message has the retained boolean set to true if the message was published\n   *                     with the retained boolean set to true\n   *                     and the subscrption was made after the message has been published.\n   * @throws {InvalidState} if the client is not connected.\n   */\n  send(topic: string | Message, payload: string, qos: 0 | 1 | 2, retained: boolean) {\n    let message;\n\n    if (arguments.length === 0) {\n      throw new Error('Invalid argument.' + 'length');\n\n    } else if (arguments.length === 1) {\n\n      if (!(topic instanceof Message)) {\n        throw new Error('Invalid argument:' + typeof topic);\n      }\n\n      message = topic;\n      if (typeof message.destinationName === 'undefined') {\n        throw new Error(format(ERROR.INVALID_ARGUMENT, [message.destinationName, 'Message.destinationName']));\n      }\n      this._client.send(message);\n\n    } else if (typeof topic === 'string') {\n      //parameter checking in Message object\n      message = new Message(payload);\n      message.destinationName = topic;\n      if (arguments.length >= 3) {\n        message.qos = qos;\n      }\n      if (arguments.length >= 4) {\n        message.retained = retained;\n      }\n      this._client.send(message);\n    }\n  }\n\n  /**\n   * Normal disconnect of this Messaging client from its server.\n   *\n   * @name Client#disconnect\n   * @function\n   * @throws {InvalidState} if the client is already disconnected.\n   */\n  disconnect() {\n    return new Promise((resolve, reject) => {\n      this.once('connectionLost', (error) => {\n        if (error && error.errorCode !== 0) {\n          return reject(error);\n        }\n        resolve();\n      });\n      this._client.disconnect();\n    });\n  }\n\n  /**\n   * Get the contents of the trace log.\n   *\n   * @name Client#getTraceLog\n   * @function\n   * @return {Object[]} tracebuffer containing the time ordered trace records.\n   */\n  getTraceLog() {\n    return this._client.getTraceLog();\n  }\n\n  /**\n   * Start tracing.\n   *\n   * @name Client#startTrace\n   * @function\n   */\n  startTrace() {\n    this._client.startTrace();\n  }\n\n  /**\n   * Stop tracing.\n   *\n   * @name Client#stopTrace\n   * @function\n   */\n  stopTrace() {\n    this._client.stopTrace();\n  }\n\n  isConnected() {\n    return this._client.connected;\n  }\n\n  get uri(): string {\n    return this._client.uri;\n  }\n\n  get clientId(): ?string {\n    return this._client.clientId;\n  }\n\n  get trace(): ?Function {\n    return this._client.traceFunction;\n  }\n\n  set trace(trace: Function) {\n    if (typeof trace === 'function') {\n      this._client.traceFunction = trace;\n    } else {\n      throw new Error(format(ERROR.INVALID_TYPE, [typeof trace, 'onTrace']));\n    }\n  }\n}\n"]},"metadata":{},"sourceType":"script"}
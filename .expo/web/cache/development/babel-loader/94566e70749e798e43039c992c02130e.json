{"ast":null,"code":"\"use strict\";\n\nvar _regeneratorRuntime = require(\"@babel/runtime/regenerator\");\n\nvar _classCallCheck = require(\"@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"@babel/runtime/helpers/createClass\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar constants_1 = require(\"./types/constants\");\n\nrequire(\"react-native-get-random-values\");\n\nvar uuid_1 = require(\"uuid\");\n\nvar react_native_paho_mqtt_1 = require(\"react-native-paho-mqtt\");\n\nvar utils_1 = require(\"./utils\");\n\nvar REGISTRATIONTOPIC = \"$dps/registrations/res\";\nvar myStorage = {\n  setItem: function setItem(key, item) {\n    myStorage[key] = item;\n  },\n  getItem: function getItem(key) {\n    return myStorage[key];\n  },\n  removeItem: function removeItem(key) {\n    delete myStorage[key];\n  }\n};\n\nvar ProvisioningClient = function () {\n  function ProvisioningClient(endpoint, registrationId, scopeId, deviceKey) {\n    _classCallCheck(this, ProvisioningClient);\n\n    this.endpoint = endpoint;\n    this.registrationId = registrationId;\n    this.scopeId = scopeId;\n    this.deviceKey = \"\";\n    this.certificate = null;\n    this.subscriptions = {};\n\n    if (typeof deviceKey === \"string\") {\n      this.deviceKey = deviceKey;\n    } else {\n      this.certificate = deviceKey;\n    }\n\n    var clientId = registrationId;\n    this.mqttUser = scopeId + \"/registrations/\" + registrationId + \"/api-version=\" + constants_1.DPS_API_VERSION;\n    var resourceUri = scopeId + \"/registrations/\" + registrationId;\n    var expiry = Math.floor(Date.now() / 1000) + 21600;\n    var signature = encodeURIComponent(utils_1.computeKey(this.deviceKey, resourceUri + \"\\n\" + expiry));\n    this.mqttPassword = \"SharedAccessSignature sr=\" + resourceUri + \"&sig=\" + signature + \"&se=\" + expiry + \"&skn=registration\";\n    this.requestId = uuid_1.v4();\n    this.mqttClient = new react_native_paho_mqtt_1.Client({\n      uri: \"wss://\" + this.endpoint + \":443/mqtt\",\n      clientId: clientId,\n      storage: myStorage,\n      webSocket: WebSocket\n    });\n    this.retry = 0;\n    this.connected = false;\n  }\n\n  _createClass(ProvisioningClient, [{\n    key: \"onRegistrationResult\",\n    value: function onRegistrationResult(topic, message, resolve, reject) {\n      var _this = this;\n\n      var match, status, requestId, retry, operationId, msg, res;\n      return _regeneratorRuntime.async(function onRegistrationResult$(_context2) {\n        while (1) {\n          switch (_context2.prev = _context2.next) {\n            case 0:\n              match = topic.match(/\\$dps\\/registrations\\/res\\/(\\d+)\\/\\?\\$rid=([\\w\\d\\-]+)(&retry-after=(\\d))?$/);\n\n              if (!(match && match.length > 1)) {\n                _context2.next = 22;\n                break;\n              }\n\n              status = +match[1];\n              requestId = match[2];\n              retry = +match[4];\n\n              if (!(requestId === this.requestId)) {\n                _context2.next = 22;\n                break;\n              }\n\n              _context2.t0 = status;\n              _context2.next = _context2.t0 === 202 ? 9 : _context2.t0 === 200 ? 15 : 21;\n              break;\n\n            case 9:\n              operationId = JSON.parse(message).operationId;\n              msg = new react_native_paho_mqtt_1.Message(\"\");\n              msg.destinationName = \"$dps/registrations/GET/iotdps-get-operationstatus/?$rid=\" + requestId + \"&operationId=\" + operationId;\n              _context2.next = 14;\n              return _regeneratorRuntime.awrap(new Promise(function (r) {\n                return setTimeout(function _callee() {\n                  return _regeneratorRuntime.async(function _callee$(_context) {\n                    while (1) {\n                      switch (_context.prev = _context.next) {\n                        case 0:\n                          _context.next = 2;\n                          return _regeneratorRuntime.awrap(_this.mqttClient.send(msg));\n\n                        case 2:\n                          r();\n\n                        case 3:\n                        case \"end\":\n                          return _context.stop();\n                      }\n                    }\n                  }, null, null, null, Promise);\n                }, (retry + 2) * 1000);\n              }));\n\n            case 14:\n              return _context2.abrupt(\"break\", 22);\n\n            case 15:\n              res = JSON.parse(message);\n              _context2.next = 18;\n              return _regeneratorRuntime.awrap(this.mqttClient.disconnect());\n\n            case 18:\n              if (res.status === \"failed\") {\n                reject(message);\n              }\n\n              resolve(utils_1.generateHubCredentials(res.registrationState.assignedHub, this.registrationId, this.deviceKey));\n              return _context2.abrupt(\"break\", 22);\n\n            case 21:\n              reject(message);\n\n            case 22:\n            case \"end\":\n              return _context2.stop();\n          }\n        }\n      }, null, this, null, Promise);\n    }\n  }, {\n    key: \"register\",\n    value: function register(modelId) {\n      var _this2 = this;\n\n      var payload;\n      return _regeneratorRuntime.async(function register$(_context4) {\n        while (1) {\n          switch (_context4.prev = _context4.next) {\n            case 0:\n              payload = {\n                registrationId: this.registrationId\n              };\n\n              if (modelId) {\n                payload[\"payload\"] = {\n                  iotcModelId: modelId,\n                  modelId: modelId\n                };\n              }\n\n              return _context4.abrupt(\"return\", new Promise(function _callee2(resolve, reject) {\n                var onMessageReceived, msg;\n                return _regeneratorRuntime.async(function _callee2$(_context3) {\n                  while (1) {\n                    switch (_context3.prev = _context3.next) {\n                      case 0:\n                        _this2.subscriptions[REGISTRATIONTOPIC] = _this2.onRegistrationResult.bind(_this2);\n\n                        onMessageReceived = function onMessageReceived(message) {\n                          if (message.destinationName.startsWith(REGISTRATIONTOPIC)) {\n                            this.subscriptions[REGISTRATIONTOPIC](message.destinationName, message.payloadString, resolve, reject);\n                          }\n                        };\n\n                        _this2.mqttClient.on(\"messageReceived\", onMessageReceived.bind(_this2));\n\n                        _context3.prev = 3;\n                        _context3.next = 6;\n                        return _regeneratorRuntime.awrap(_this2.clientConnect());\n\n                      case 6:\n                        _context3.next = 8;\n                        return _regeneratorRuntime.awrap(_this2.mqttClient.subscribe(REGISTRATIONTOPIC + \"/#\"));\n\n                      case 8:\n                        msg = new react_native_paho_mqtt_1.Message(JSON.stringify(payload));\n                        msg.destinationName = \"$dps/registrations/PUT/iotdps-register/?$rid=\" + _this2.requestId;\n                        _context3.next = 12;\n                        return _regeneratorRuntime.awrap(_this2.mqttClient.send(msg));\n\n                      case 12:\n                        _context3.next = 17;\n                        break;\n\n                      case 14:\n                        _context3.prev = 14;\n                        _context3.t0 = _context3[\"catch\"](3);\n                        reject(_context3.t0);\n\n                      case 17:\n                      case \"end\":\n                        return _context3.stop();\n                    }\n                  }\n                }, null, null, [[3, 14]], Promise);\n              }));\n\n            case 3:\n            case \"end\":\n              return _context4.stop();\n          }\n        }\n      }, null, this, null, Promise);\n    }\n  }, {\n    key: \"clientConnect\",\n    value: function clientConnect() {\n      return _regeneratorRuntime.async(function clientConnect$(_context5) {\n        while (1) {\n          switch (_context5.prev = _context5.next) {\n            case 0:\n              if (!(this.retry == 5)) {\n                _context5.next = 2;\n                break;\n              }\n\n              throw new Error(\"No connection after multiple retries\");\n\n            case 2:\n              if (!(!this.mqttClient || this.connected)) {\n                _context5.next = 4;\n                break;\n              }\n\n              return _context5.abrupt(\"return\");\n\n            case 4:\n              _context5.prev = 4;\n              _context5.next = 7;\n              return _regeneratorRuntime.awrap(this.mqttClient.connect({\n                userName: this.mqttUser,\n                password: this.mqttPassword\n              }));\n\n            case 7:\n              _context5.next = 14;\n              break;\n\n            case 9:\n              _context5.prev = 9;\n              _context5.t0 = _context5[\"catch\"](4);\n              this.retry++;\n              _context5.next = 14;\n              return _regeneratorRuntime.awrap(this.clientConnect());\n\n            case 14:\n              this.connected = true;\n\n            case 15:\n            case \"end\":\n              return _context5.stop();\n          }\n        }\n      }, null, this, [[4, 9]], Promise);\n    }\n  }], [{\n    key: \"createKeyClient\",\n    value: function createKeyClient(endpoint, registrationId, scopeId, connType, key) {\n      if (connType != constants_1.IOTC_CONNECT.SYMM_KEY && connType != constants_1.IOTC_CONNECT.DEVICE_KEY) {\n        throw new Error(\"Can't create a key client with a different credential method\");\n      }\n\n      if (connType == constants_1.IOTC_CONNECT.SYMM_KEY) {\n        key = utils_1.computeKey(key, registrationId);\n      }\n\n      return new ProvisioningClient(endpoint, registrationId, scopeId, key);\n    }\n  }, {\n    key: \"createCertificateClient\",\n    value: function createCertificateClient(endpoint, registrationId, scopeId, connType, key) {\n      if (connType == constants_1.IOTC_CONNECT.SYMM_KEY || connType == constants_1.IOTC_CONNECT.DEVICE_KEY) {\n        throw new Error(\"Can't create a certificate client with a different credential method\");\n      }\n\n      return new ProvisioningClient(endpoint, registrationId, scopeId, key);\n    }\n  }]);\n\n  return ProvisioningClient;\n}();\n\nexports.default = ProvisioningClient;","map":{"version":3,"sources":["../src/provision.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst constants_1 = require(\"./types/constants\");\nrequire(\"react-native-get-random-values\");\nconst uuid_1 = require(\"uuid\");\nconst react_native_paho_mqtt_1 = require(\"react-native-paho-mqtt\");\nconst utils_1 = require(\"./utils\");\nconst REGISTRATIONTOPIC = \"$dps/registrations/res\";\n// Set up an in-memory alternative to global localStorage\nconst myStorage = {\n    setItem: (key, item) => {\n        myStorage[key] = item;\n    },\n    getItem: (key) => myStorage[key],\n    removeItem: (key) => {\n        delete myStorage[key];\n    },\n};\nclass ProvisioningClient {\n    constructor(endpoint, registrationId, scopeId, deviceKey) {\n        this.endpoint = endpoint;\n        this.registrationId = registrationId;\n        this.scopeId = scopeId;\n        this.deviceKey = \"\";\n        this.certificate = null;\n        this.subscriptions = {};\n        if (typeof deviceKey === \"string\") {\n            this.deviceKey = deviceKey;\n        }\n        else {\n            this.certificate = deviceKey;\n        }\n        const clientId = registrationId;\n        this.mqttUser = `${scopeId}/registrations/${registrationId}/api-version=${constants_1.DPS_API_VERSION}`;\n        const resourceUri = `${scopeId}/registrations/${registrationId}`;\n        const expiry = Math.floor(Date.now() / 1000) + 21600; // 6 hours\n        const signature = encodeURIComponent(utils_1.computeKey(this.deviceKey, `${resourceUri}\\n${expiry}`));\n        this.mqttPassword = `SharedAccessSignature sr=${resourceUri}&sig=${signature}&se=${expiry}&skn=registration`;\n        this.requestId = uuid_1.v4();\n        this.mqttClient = new react_native_paho_mqtt_1.Client({\n            uri: `wss://${this.endpoint}:443/mqtt`,\n            clientId,\n            storage: myStorage,\n            webSocket: WebSocket,\n        });\n        this.retry = 0;\n        this.connected = false;\n    }\n    static createKeyClient(endpoint, registrationId, scopeId, connType, key) {\n        if (connType != constants_1.IOTC_CONNECT.SYMM_KEY &&\n            connType != constants_1.IOTC_CONNECT.DEVICE_KEY) {\n            throw new Error(\"Can't create a key client with a different credential method\");\n        }\n        if (connType == constants_1.IOTC_CONNECT.SYMM_KEY) {\n            key = utils_1.computeKey(key, registrationId);\n        }\n        return new ProvisioningClient(endpoint, registrationId, scopeId, key);\n    }\n    static createCertificateClient(endpoint, registrationId, scopeId, connType, key) {\n        if (connType == constants_1.IOTC_CONNECT.SYMM_KEY ||\n            connType == constants_1.IOTC_CONNECT.DEVICE_KEY) {\n            throw new Error(\"Can't create a certificate client with a different credential method\");\n        }\n        return new ProvisioningClient(endpoint, registrationId, scopeId, key);\n    }\n    async onRegistrationResult(topic, message, resolve, reject) {\n        const match = topic.match(/\\$dps\\/registrations\\/res\\/(\\d+)\\/\\?\\$rid=([\\w\\d\\-]+)(&retry-after=(\\d))?$/);\n        if (match && match.length > 1) {\n            const status = +match[1];\n            const requestId = match[2];\n            const retry = +match[4];\n            if (requestId === this.requestId) {\n                switch (status) {\n                    case 202:\n                        // poll\n                        const operationId = JSON.parse(message).operationId;\n                        const msg = new react_native_paho_mqtt_1.Message(\"\");\n                        msg.destinationName = `$dps/registrations/GET/iotdps-get-operationstatus/?$rid=${requestId}&operationId=${operationId}`;\n                        await new Promise((r) => setTimeout(async () => {\n                            await this.mqttClient.send(msg);\n                            r();\n                        }, (retry + 2) * 1000)); // add 2 seconds to retry to give more time\n                        break;\n                    case 200:\n                        // get result\n                        const res = JSON.parse(message);\n                        await this.mqttClient.disconnect();\n                        if (res.status === \"failed\") {\n                            reject(message);\n                        }\n                        resolve(utils_1.generateHubCredentials(res.registrationState.assignedHub, this.registrationId, this.deviceKey));\n                        break;\n                    default:\n                        reject(message);\n                }\n            }\n        }\n    }\n    async register(modelId) {\n        let payload = {\n            registrationId: this.registrationId,\n        };\n        if (modelId) {\n            payload[\"payload\"] = {\n                iotcModelId: modelId,\n                modelId: modelId,\n            };\n        }\n        return new Promise(async (resolve, reject) => {\n            this.subscriptions[REGISTRATIONTOPIC] = this.onRegistrationResult.bind(this);\n            const onMessageReceived = function (message) {\n                if (message.destinationName.startsWith(REGISTRATIONTOPIC)) {\n                    this.subscriptions[REGISTRATIONTOPIC](message.destinationName, message.payloadString, resolve, reject);\n                }\n            };\n            this.mqttClient.on(\"messageReceived\", onMessageReceived.bind(this));\n            try {\n                await this.clientConnect();\n                await this.mqttClient.subscribe(`${REGISTRATIONTOPIC}/#`);\n                let msg = new react_native_paho_mqtt_1.Message(JSON.stringify(payload));\n                msg.destinationName = `$dps/registrations/PUT/iotdps-register/?$rid=${this.requestId}`;\n                await this.mqttClient.send(msg);\n            }\n            catch (ex) {\n                reject(ex);\n            }\n        });\n    }\n    async clientConnect() {\n        if (this.retry == 5) {\n            throw new Error(\"No connection after multiple retries\");\n        }\n        if (!this.mqttClient || this.connected) {\n            return;\n        }\n        try {\n            await this.mqttClient.connect({\n                userName: this.mqttUser,\n                password: this.mqttPassword,\n            });\n        }\n        catch (ex) {\n            // retry\n            this.retry++;\n            await this.clientConnect();\n        }\n        this.connected = true;\n    }\n}\nexports.default = ProvisioningClient;\n//# sourceMappingURL=provision.js.map"]},"metadata":{},"sourceType":"script"}
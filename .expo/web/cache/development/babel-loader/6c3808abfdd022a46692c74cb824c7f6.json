{"ast":null,"code":"var _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _classCallCheck2 = _interopRequireDefault(require(\"@babel/runtime/helpers/classCallCheck\"));\n\nvar _createClass2 = _interopRequireDefault(require(\"@babel/runtime/helpers/createClass\"));\n\nvar _util = require(\"./util\");\n\nvar _constants = require(\"./constants\");\n\nvar _default = function () {\n  function _default(newPayload) {\n    (0, _classCallCheck2.default)(this, _default);\n    this._qos = 0;\n    this._retained = false;\n    this._duplicate = false;\n\n    if (!(typeof newPayload === 'string' || newPayload instanceof Uint8Array)) {\n      throw (0, _util.format)(_constants.ERROR.INVALID_ARGUMENT, [newPayload.toString(), 'newPayload']);\n    }\n\n    this._payload = newPayload;\n  }\n\n  (0, _createClass2.default)(_default, [{\n    key: \"payloadString\",\n    get: function get() {\n      if (typeof this._payload === 'string') {\n        return this._payload;\n      } else {\n        return (0, _util.parseUTF8)(this._payload, 0, this._payload.byteLength);\n      }\n    }\n  }, {\n    key: \"payloadBytes\",\n    get: function get() {\n      var payload = this._payload;\n\n      if (typeof payload === 'string') {\n        var buffer = new ArrayBuffer((0, _util.lengthOfUTF8)(payload));\n        var byteStream = new Uint8Array(buffer);\n        (0, _util.stringToUTF8)(payload, byteStream, 0);\n        return byteStream;\n      } else {\n        return payload;\n      }\n    }\n  }, {\n    key: \"destinationName\",\n    get: function get() {\n      return this._destinationName;\n    },\n    set: function set(newDestinationName) {\n      if (typeof newDestinationName === 'string') {\n        this._destinationName = newDestinationName;\n      } else {\n        throw new Error((0, _util.format)(_constants.ERROR.INVALID_ARGUMENT, [newDestinationName, 'newDestinationName']));\n      }\n    }\n  }, {\n    key: \"qos\",\n    get: function get() {\n      return this._qos;\n    },\n    set: function set(newQos) {\n      if (newQos === 0 || newQos === 1 || newQos === 2) {\n        this._qos = newQos;\n      } else {\n        throw new Error('Invalid argument:' + newQos);\n      }\n    }\n  }, {\n    key: \"retained\",\n    get: function get() {\n      return this._retained;\n    },\n    set: function set(newRetained) {\n      if (typeof newRetained === 'boolean') {\n        this._retained = newRetained;\n      } else {\n        throw new Error((0, _util.format)(_constants.ERROR.INVALID_ARGUMENT, [newRetained, 'newRetained']));\n      }\n    }\n  }, {\n    key: \"duplicate\",\n    get: function get() {\n      return this._duplicate;\n    },\n    set: function set(newDuplicate) {\n      if (typeof newDuplicate === 'boolean') {\n        this._duplicate = newDuplicate;\n      } else {\n        throw new Error((0, _util.format)(_constants.ERROR.INVALID_ARGUMENT, [newDuplicate, 'newDuplicate']));\n      }\n    }\n  }]);\n  return _default;\n}();\n\nexports.default = _default;","map":{"version":3,"sources":["C:/Users/venkatesh.devireddy/Projects/IoT_Central_CPM/node_modules/react-native-azure-iotcentral-client/node_modules/react-native-paho-mqtt/src/Message.js"],"names":["newPayload","_qos","_retained","_duplicate","Uint8Array","ERROR","INVALID_ARGUMENT","toString","_payload","byteLength","payload","buffer","ArrayBuffer","byteStream","_destinationName","newDestinationName","Error","newQos","newRetained","newDuplicate"],"mappings":";;;;;;;;;;;AAEA;;AACA;;;AA6CE,oBAAYA,UAAZ,EAAiC;AAAA;AAAA,SAJjCC,IAIiC,GAJf,CAIe;AAAA,SAHjCC,SAGiC,GAHZ,KAGY;AAAA,SAFjCC,UAEiC,GAFX,KAEW;;AAC/B,QAAI,EAAE,OAAOH,UAAP,KAAsB,QAAtB,IACCA,UAAU,YAAYI,UADzB,CAAJ,EAEK;AACH,YAAO,kBAAOC,iBAAMC,gBAAb,EAA+B,CAACN,UAAU,CAACO,QAAX,EAAD,EAAwB,YAAxB,CAA/B,CAAP;AACD;;AACD,SAAKC,QAAL,GAAgBR,UAAhB;AACD;;;;SAED,eAA4B;AAC1B,UAAI,OAAO,KAAKQ,QAAZ,KAAyB,QAA7B,EAAuC;AACrC,eAAO,KAAKA,QAAZ;AACD,OAFD,MAEO;AACL,eAAO,qBAAU,KAAKA,QAAf,EAAyB,CAAzB,EAA4B,KAAKA,QAAL,CAAcC,UAA1C,CAAP;AACD;AACF;;;SAED,eAA+B;AAC7B,UAAMC,OAAO,GAAG,KAAKF,QAArB;;AACA,UAAI,OAAOE,OAAP,KAAmB,QAAvB,EAAiC;AAC/B,YAAMC,MAAM,GAAG,IAAIC,WAAJ,CAAgB,wBAAaF,OAAb,CAAhB,CAAf;AACA,YAAMG,UAAU,GAAG,IAAIT,UAAJ,CAAeO,MAAf,CAAnB;AACA,gCAAaD,OAAb,EAAsBG,UAAtB,EAAkC,CAAlC;AAEA,eAAOA,UAAP;AACD,OAND,MAMO;AACL,eAAOH,OAAP;AACD;AACF;;;SAED,eAA8B;AAC5B,aAAO,KAAKI,gBAAZ;AACD,K;SAED,aAAoBC,kBAApB,EAAgD;AAC9C,UAAI,OAAOA,kBAAP,KAA8B,QAAlC,EAA4C;AAC1C,aAAKD,gBAAL,GAAwBC,kBAAxB;AACD,OAFD,MAEO;AACL,cAAM,IAAIC,KAAJ,CAAU,kBAAOX,iBAAMC,gBAAb,EAA+B,CAACS,kBAAD,EAAqB,oBAArB,CAA/B,CAAV,CAAN;AACD;AACF;;;SAED,eAAqB;AACnB,aAAO,KAAKd,IAAZ;AACD,K;SAED,aAAQgB,MAAR,EAA2B;AACzB,UAAIA,MAAM,KAAK,CAAX,IAAgBA,MAAM,KAAK,CAA3B,IAAgCA,MAAM,KAAK,CAA/C,EAAkD;AAChD,aAAKhB,IAAL,GAAYgB,MAAZ;AACD,OAFD,MAEO;AACL,cAAM,IAAID,KAAJ,CAAU,sBAAsBC,MAAhC,CAAN;AACD;AACF;;;SAED,eAAwB;AACtB,aAAO,KAAKf,SAAZ;AACD,K;SAED,aAAagB,WAAb,EAAmC;AACjC,UAAI,OAAOA,WAAP,KAAuB,SAA3B,EAAsC;AACpC,aAAKhB,SAAL,GAAiBgB,WAAjB;AACD,OAFD,MAEO;AACL,cAAM,IAAIF,KAAJ,CAAU,kBAAOX,iBAAMC,gBAAb,EAA+B,CAACY,WAAD,EAAc,aAAd,CAA/B,CAAV,CAAN;AACD;AACF;;;SAED,eAAyB;AACvB,aAAO,KAAKf,UAAZ;AACD,K;SAED,aAAcgB,YAAd,EAAqC;AACnC,UAAI,OAAOA,YAAP,KAAwB,SAA5B,EAAuC;AACrC,aAAKhB,UAAL,GAAkBgB,YAAlB;AACD,OAFD,MAEO;AACL,cAAM,IAAIH,KAAJ,CAAU,kBAAOX,iBAAMC,gBAAb,EAA+B,CAACa,YAAD,EAAe,cAAf,CAA/B,CAAV,CAAN;AACD;AACF","sourcesContent":["/* @flow */\n\nimport { format, lengthOfUTF8, parseUTF8, stringToUTF8 } from './util';\nimport { ERROR } from './constants';\n\ntype Payload = string | Uint8Array;\n\n/**\n * An application message, sent or received.\n * <p>\n * All attributes may be null, which implies the default values.\n *\n * @name Message\n * @constructor\n * @param {String|ArrayBuffer} newPayload The message data to be sent.\n * <p>\n * @property {string} payloadString <i>read only</i> The payload as a string if the payload consists of valid UTF-8 characters.\n * @property {ArrayBuffer} payloadBytes <i>read only</i> The payload as an ArrayBuffer.\n * <p>\n * @property {string} destinationName <b>mandatory</b> The name of the destination to which the message is to be sent\n *                    (for messages about to be sent) or the name of the destination from which the message has been received.\n *                    (for messages received by the onMessage function).\n * <p>\n * @property {number} qos The Quality of Service used to deliver the message.\n * <dl>\n *     <dt>0 Best effort (default).\n *     <dt>1 At least once.\n *     <dt>2 Exactly once.\n * </dl>\n * <p>\n * @property {Boolean} retained If true, the message is to be retained by the server and delivered\n *                     to both current and future subscriptions.\n *                     If false the server only delivers the message to current subscribers, this is the default for new Messages.\n *                     A received message has the retained boolean set to true if the message was published\n *                     with the retained boolean set to true\n *                     and the subscrption was made after the message has been published.\n * <p>\n * @property {Boolean} duplicate <i>read only</i> If true, this message might be a duplicate of one which has already been received.\n *                     This is only set on messages received from the server.\n *\n */\nexport default class {\n  _payload: Payload;\n  _destinationName: string;\n  _qos: 0 | 1 | 2 = 0;\n  _retained: boolean = false;\n  _duplicate: boolean = false;\n\n  constructor(newPayload: Payload) {\n    if (!(typeof newPayload === 'string'\n        || newPayload instanceof Uint8Array\n      )) {\n      throw (format(ERROR.INVALID_ARGUMENT, [newPayload.toString(), 'newPayload']));\n    }\n    this._payload = newPayload;\n  }\n\n  get payloadString(): string {\n    if (typeof this._payload === 'string') {\n      return this._payload;\n    } else {\n      return parseUTF8(this._payload, 0, this._payload.byteLength);\n    }\n  }\n\n  get payloadBytes(): Uint8Array {\n    const payload = this._payload;\n    if (typeof payload === 'string') {\n      const buffer = new ArrayBuffer(lengthOfUTF8(payload));\n      const byteStream = new Uint8Array(buffer);\n      stringToUTF8(payload, byteStream, 0);\n\n      return byteStream;\n    } else {\n      return payload;\n    }\n  }\n\n  get destinationName(): string {\n    return this._destinationName;\n  }\n\n  set destinationName(newDestinationName: string) {\n    if (typeof newDestinationName === 'string') {\n      this._destinationName = newDestinationName;\n    } else {\n      throw new Error(format(ERROR.INVALID_ARGUMENT, [newDestinationName, 'newDestinationName']));\n    }\n  }\n\n  get qos(): 0 | 1 | 2 {\n    return this._qos;\n  }\n\n  set qos(newQos: 0 | 1 | 2) {\n    if (newQos === 0 || newQos === 1 || newQos === 2) {\n      this._qos = newQos;\n    } else {\n      throw new Error('Invalid argument:' + newQos);\n    }\n  }\n\n  get retained(): boolean {\n    return this._retained;\n  }\n\n  set retained(newRetained: boolean) {\n    if (typeof newRetained === 'boolean') {\n      this._retained = newRetained;\n    } else {\n      throw new Error(format(ERROR.INVALID_ARGUMENT, [newRetained, 'newRetained']));\n    }\n  }\n\n  get duplicate(): boolean {\n    return this._duplicate;\n  }\n\n  set duplicate(newDuplicate: boolean) {\n    if (typeof newDuplicate === 'boolean') {\n      this._duplicate = newDuplicate;\n    } else {\n      throw new Error(format(ERROR.INVALID_ARGUMENT, [newDuplicate, 'newDuplicate']));\n    }\n  }\n}\n"]},"metadata":{},"sourceType":"script"}
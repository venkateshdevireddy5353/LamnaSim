{"ast":null,"code":"var _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _defineProperty2 = _interopRequireDefault(require(\"@babel/runtime/helpers/defineProperty\"));\n\nvar _classCallCheck2 = _interopRequireDefault(require(\"@babel/runtime/helpers/classCallCheck\"));\n\nvar _createClass2 = _interopRequireDefault(require(\"@babel/runtime/helpers/createClass\"));\n\nvar _Message = _interopRequireDefault(require(\"./Message\"));\n\nvar _util = require(\"./util\");\n\nvar _constants = require(\"./constants\");\n\nvar _Pinger = _interopRequireDefault(require(\"./Pinger\"));\n\nvar _WireMessage = _interopRequireDefault(require(\"./WireMessage\"));\n\nvar _PublishMessage = _interopRequireDefault(require(\"./PublishMessage\"));\n\nvar _ConnectMessage = _interopRequireDefault(require(\"./ConnectMessage\"));\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { (0, _defineProperty2.default)(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nvar ClientImplementation = function () {\n  function ClientImplementation(uri, clientId, storage, ws) {\n    var _this = this;\n\n    (0, _classCallCheck2.default)(this, ClientImplementation);\n    this.connected = false;\n    this.maxOutboundInFlight = 65536;\n    this._msg_queue = null;\n    this.sendPinger = null;\n    this.receiveBuffer = null;\n    this._traceBuffer = null;\n    this._MAX_TRACE_ENTRIES = 100;\n    this._messagesAwaitingDispatch = [];\n    this._outboundMessagesInFlight = {};\n    this._receivedMessagesAwaitingAckConfirm = {};\n    this._nextMessageId = 1;\n    this._sequence = 0;\n\n    if (!ws && !(window && window.WebSocket)) {\n      throw new Error((0, _util.format)(_constants.ERROR.UNSUPPORTED, ['WebSocket']));\n    }\n\n    if (!storage && !(window && window.localStorage)) {\n      throw new Error((0, _util.format)(_constants.ERROR.UNSUPPORTED, ['localStorage']));\n    }\n\n    if (!(window && window.ArrayBuffer)) {\n      throw new Error((0, _util.format)(_constants.ERROR.UNSUPPORTED, ['ArrayBuffer']));\n    }\n\n    this._trace('Client', uri, clientId);\n\n    this.uri = uri;\n    this.clientId = clientId;\n    this.storage = storage || window.localStorage;\n    this.webSocket = ws || window.WebSocket;\n    this._localKey = uri + ':' + clientId + ':';\n    Object.keys(this.storage).forEach(function (key) {\n      if (key.indexOf('Sent:' + _this._localKey) === 0 || key.indexOf('Received:' + _this._localKey) === 0) {\n        _this.restore(key);\n      }\n    });\n  }\n\n  (0, _createClass2.default)(ClientImplementation, [{\n    key: \"connect\",\n    value: function connect(connectOptions) {\n      var _this2 = this;\n\n      var maskedCopy = _objectSpread({}, connectOptions);\n\n      if (maskedCopy.password) {\n        maskedCopy.password = 'REDACTED';\n      }\n\n      this._trace('Client.connect', maskedCopy, this.socket, this.connected);\n\n      if (this.connected) {\n        throw new Error((0, _util.format)(_constants.ERROR.INVALID_STATE, ['already connected']));\n      }\n\n      if (this.socket) {\n        throw new Error((0, _util.format)(_constants.ERROR.INVALID_STATE, ['already connected']));\n      }\n\n      this.connectOptions = connectOptions;\n      this.connected = false;\n      this.socket = new this.webSocket(this.uri, ['mqtt' + (connectOptions.mqttVersion === 3 ? 'v3.1' : '')]);\n      this.socket.binaryType = 'arraybuffer';\n\n      this.socket.onopen = function () {\n        var willMessage = connectOptions.willMessage,\n            mqttVersion = connectOptions.mqttVersion,\n            userName = connectOptions.userName,\n            password = connectOptions.password,\n            cleanSession = connectOptions.cleanSession,\n            keepAliveInterval = connectOptions.keepAliveInterval;\n        var wireMessage = new _ConnectMessage.default({\n          cleanSession: cleanSession,\n          userName: userName,\n          password: password,\n          mqttVersion: mqttVersion,\n          willMessage: willMessage,\n          keepAliveInterval: keepAliveInterval,\n          clientId: _this2.clientId\n        });\n\n        _this2._trace('socket.send', _objectSpread(_objectSpread({}, wireMessage), {}, {\n          options: maskedCopy\n        }));\n\n        _this2.socket && (_this2.socket.onopen = function () {\n          return null;\n        });\n        var delay = 0;\n\n        if (connectOptions.delay) {\n          delay = connectOptions.delay * 1000;\n        }\n\n        setTimeout(function () {\n          _this2.socket && _this2.socket.send(wireMessage.encode());\n        }, delay);\n      };\n\n      this.socket.onmessage = function (event) {\n        _this2._trace('socket.onmessage', event.data);\n\n        var messages = _this2._deframeMessages(event.data);\n\n        messages && messages.forEach(function (message) {\n          return _this2._handleMessage(message);\n        });\n      };\n\n      this.socket.onerror = function (error) {\n        return _this2._disconnected(_constants.ERROR.SOCKET_ERROR.code, (0, _util.format)(_constants.ERROR.SOCKET_ERROR, [error.data || ' Unknown socket error']));\n      };\n\n      this.socket.onclose = function () {\n        return _this2._disconnected(_constants.ERROR.SOCKET_CLOSE.code, (0, _util.format)(_constants.ERROR.SOCKET_CLOSE));\n      };\n\n      if (connectOptions.keepAliveInterval > 0) {\n        this.sendPinger = new _Pinger.default(this, connectOptions.keepAliveInterval);\n      }\n\n      if (connectOptions.timeout) {\n        this._connectTimeout = setTimeout(function () {\n          _this2._disconnected(_constants.ERROR.CONNECT_TIMEOUT.code, (0, _util.format)(_constants.ERROR.CONNECT_TIMEOUT));\n        }, connectOptions.timeout);\n      }\n    }\n  }, {\n    key: \"subscribe\",\n    value: function subscribe(filter, subscribeOptions) {\n      this._trace('Client.subscribe', filter, subscribeOptions);\n\n      if (!this.connected) {\n        throw new Error((0, _util.format)(_constants.ERROR.INVALID_STATE, ['not connected']));\n      }\n\n      var wireMessage = new _WireMessage.default(_constants.MESSAGE_TYPE.SUBSCRIBE);\n      wireMessage.topics = [filter];\n      wireMessage.requestedQos = [subscribeOptions.qos || 0];\n\n      if (subscribeOptions.onSuccess) {\n        wireMessage.subAckReceived = function (grantedQos) {\n          subscribeOptions.onSuccess({\n            grantedQos: grantedQos\n          });\n        };\n      }\n\n      if (subscribeOptions.onFailure) {\n        wireMessage.onFailure = subscribeOptions.onFailure;\n      }\n\n      if (subscribeOptions.timeout && subscribeOptions.onFailure) {\n        wireMessage.timeOut = setTimeout(function () {\n          subscribeOptions.onFailure(new Error((0, _util.format)(_constants.ERROR.SUBSCRIBE_TIMEOUT)));\n        }, subscribeOptions.timeout);\n      }\n\n      this._requires_ack(wireMessage);\n\n      this._scheduleMessage(wireMessage);\n    }\n  }, {\n    key: \"unsubscribe\",\n    value: function unsubscribe(filter, unsubscribeOptions) {\n      this._trace('Client.unsubscribe', filter, unsubscribeOptions);\n\n      if (!this.connected) {\n        throw new Error((0, _util.format)(_constants.ERROR.INVALID_STATE, ['not connected']));\n      }\n\n      var wireMessage = new _WireMessage.default(_constants.MESSAGE_TYPE.UNSUBSCRIBE);\n      wireMessage.topics = [filter];\n\n      if (unsubscribeOptions.onSuccess) {\n        wireMessage.unSubAckReceived = function () {\n          unsubscribeOptions.onSuccess();\n        };\n      }\n\n      if (unsubscribeOptions.timeout) {\n        wireMessage.timeOut = setTimeout(function () {\n          unsubscribeOptions.onFailure(new Error((0, _util.format)(_constants.ERROR.UNSUBSCRIBE_TIMEOUT)));\n        }, unsubscribeOptions.timeout);\n      }\n\n      this._requires_ack(wireMessage);\n\n      this._scheduleMessage(wireMessage);\n    }\n  }, {\n    key: \"send\",\n    value: function send(message) {\n      this._trace('Client.send', message);\n\n      if (!this.connected) {\n        throw new Error((0, _util.format)(_constants.ERROR.INVALID_STATE, ['not connected']));\n      }\n\n      var wireMessage = new _PublishMessage.default(message);\n\n      if (message.qos > 0) {\n        this._requires_ack(wireMessage);\n      } else if (this.onMessageDelivered) {\n        var onMessageDelivered = this.onMessageDelivered;\n\n        wireMessage.onDispatched = function () {\n          return onMessageDelivered(wireMessage.payloadMessage);\n        };\n      }\n\n      this._scheduleMessage(wireMessage);\n    }\n  }, {\n    key: \"disconnect\",\n    value: function disconnect() {\n      var _this3 = this;\n\n      this._trace('Client.disconnect');\n\n      if (!this.socket) {\n        throw new Error((0, _util.format)(_constants.ERROR.INVALID_STATE, ['not connecting or connected']));\n      }\n\n      var wireMessage = new _WireMessage.default(_constants.MESSAGE_TYPE.DISCONNECT);\n\n      wireMessage.onDispatched = function () {\n        _this3._disconnected();\n      };\n\n      this._scheduleMessage(wireMessage);\n    }\n  }, {\n    key: \"getTraceLog\",\n    value: function getTraceLog() {\n      var _this4 = this;\n\n      if (this._traceBuffer !== null) {\n        this._trace('Client.getTraceLog', new Date());\n\n        this._trace('Client.getTraceLog in flight messages', Object.keys(this._outboundMessagesInFlight).length);\n\n        Object.keys(this._outboundMessagesInFlight).forEach(function (key) {\n          _this4._trace('_outboundMessagesInFlight ', key, _this4._outboundMessagesInFlight[key]);\n        });\n        Object.keys(this._receivedMessagesAwaitingAckConfirm).forEach(function (key) {\n          _this4._trace('_receivedMessagesAwaitingAckConfirm ', key, _this4._receivedMessagesAwaitingAckConfirm[key]);\n        });\n        return this._traceBuffer;\n      }\n    }\n  }, {\n    key: \"startTrace\",\n    value: function startTrace() {\n      if (this._traceBuffer === null) {\n        this._traceBuffer = [];\n      }\n\n      this._trace('Client.startTrace', new Date());\n    }\n  }, {\n    key: \"stopTrace\",\n    value: function stopTrace() {\n      this._traceBuffer = null;\n    }\n  }, {\n    key: \"_scheduleMessage\",\n    value: function _scheduleMessage(message) {\n      this._messagesAwaitingDispatch.push(message);\n\n      if (this.connected) {\n        this._process_queue();\n      }\n    }\n  }, {\n    key: \"store\",\n    value: function store(prefix, wireMessage) {\n      var messageIdentifier = wireMessage.messageIdentifier;\n      (0, _util.invariant)(messageIdentifier, (0, _util.format)(_constants.ERROR.INVALID_STATE, ['Cannot store a WireMessage with no messageIdentifier']));\n      var storedMessage = {\n        type: wireMessage.type,\n        messageIdentifier: messageIdentifier,\n        version: 1\n      };\n\n      switch (wireMessage.type) {\n        case _constants.MESSAGE_TYPE.PUBLISH:\n          var payloadMessage = wireMessage.payloadMessage;\n          (0, _util.invariant)(payloadMessage, (0, _util.format)(_constants.ERROR.INVALID_STATE, ['PUBLISH WireMessage with no payloadMessage']));\n\n          if (wireMessage.pubRecReceived) {\n            storedMessage.pubRecReceived = true;\n          }\n\n          storedMessage.payloadMessage = {};\n          var hex = '';\n          var messageBytes = payloadMessage.payloadBytes;\n\n          for (var i = 0; i < messageBytes.length; i++) {\n            if (messageBytes[i] <= 0xF) {\n              hex = hex + '0' + messageBytes[i].toString(16);\n            } else {\n              hex = hex + messageBytes[i].toString(16);\n            }\n          }\n\n          storedMessage.payloadMessage.payloadHex = hex;\n          storedMessage.payloadMessage.qos = payloadMessage.qos;\n          storedMessage.payloadMessage.destinationName = payloadMessage.destinationName;\n\n          if (payloadMessage.duplicate) {\n            storedMessage.payloadMessage.duplicate = true;\n          }\n\n          if (payloadMessage.retained) {\n            storedMessage.payloadMessage.retained = true;\n          }\n\n          if (prefix.indexOf('Sent:') === 0) {\n            if (wireMessage.sequence === undefined) {\n              wireMessage.sequence = ++this._sequence;\n            }\n\n            storedMessage.sequence = wireMessage.sequence;\n          }\n\n          break;\n\n        default:\n          throw Error((0, _util.format)(_constants.ERROR.INVALID_STORED_DATA, [prefix + this._localKey + messageIdentifier, storedMessage]));\n      }\n\n      this.storage.setItem(prefix + this._localKey + messageIdentifier, JSON.stringify(storedMessage));\n    }\n  }, {\n    key: \"restore\",\n    value: function restore(key) {\n      var value = this.storage.getItem(key);\n      var storedMessage = JSON.parse(value);\n      var wireMessage;\n\n      switch (storedMessage.type) {\n        case _constants.MESSAGE_TYPE.PUBLISH:\n          var hex = storedMessage.payloadMessage.payloadHex;\n          var buffer = new ArrayBuffer(hex.length / 2);\n          var byteStream = new Uint8Array(buffer);\n          var i = 0;\n\n          while (hex.length >= 2) {\n            var x = parseInt(hex.substring(0, 2), 16);\n            hex = hex.substring(2, hex.length);\n            byteStream[i++] = x;\n          }\n\n          var payloadMessage = new _Message.default(byteStream);\n          payloadMessage.qos = storedMessage.payloadMessage.qos;\n          payloadMessage.destinationName = storedMessage.payloadMessage.destinationName;\n\n          if (storedMessage.payloadMessage.duplicate) {\n            payloadMessage.duplicate = true;\n          }\n\n          if (storedMessage.payloadMessage.retained) {\n            payloadMessage.retained = true;\n          }\n\n          wireMessage = new _PublishMessage.default(payloadMessage, storedMessage.messageIdentifier);\n          break;\n\n        default:\n          throw Error((0, _util.format)(_constants.ERROR.INVALID_STORED_DATA, [key, value]));\n      }\n\n      if (key.indexOf('Sent:' + this._localKey) === 0) {\n        wireMessage.payloadMessage.duplicate = true;\n        (0, _util.invariant)(wireMessage.messageIdentifier, (0, _util.format)(_constants.ERROR.INVALID_STATE, ['Stored WireMessage with no messageIdentifier']));\n        this._outboundMessagesInFlight[wireMessage.messageIdentifier.toString()] = wireMessage;\n      } else if (key.indexOf('Received:' + this._localKey) === 0) {\n        (0, _util.invariant)(wireMessage.messageIdentifier, (0, _util.format)(_constants.ERROR.INVALID_STATE, ['Stored WireMessage with no messageIdentifier']));\n        this._receivedMessagesAwaitingAckConfirm[wireMessage.messageIdentifier.toString()] = wireMessage;\n      }\n    }\n  }, {\n    key: \"_process_queue\",\n    value: function _process_queue() {\n      var socket = this.socket;\n      var wireMessage;\n\n      while (wireMessage = this._messagesAwaitingDispatch.shift()) {\n        this._trace('Client._socketSend', wireMessage);\n\n        socket && socket.send(wireMessage.encode());\n        wireMessage.onDispatched && wireMessage.onDispatched();\n      }\n\n      this.sendPinger && this.sendPinger.reset();\n    }\n  }, {\n    key: \"_requires_ack\",\n    value: function _requires_ack(wireMessage) {\n      var messageCount = Object.keys(this._outboundMessagesInFlight).length;\n\n      if (messageCount > this.maxOutboundInFlight) {\n        throw Error('Too many messages:' + messageCount);\n      }\n\n      while (this._outboundMessagesInFlight[this._nextMessageId.toString()] !== undefined) {\n        this._nextMessageId++;\n      }\n\n      wireMessage.messageIdentifier = this._nextMessageId;\n      this._outboundMessagesInFlight[wireMessage.messageIdentifier.toString()] = wireMessage;\n\n      if (wireMessage instanceof _PublishMessage.default) {\n        this.store('Sent:', wireMessage);\n      }\n\n      if (this._nextMessageId === this.maxOutboundInFlight) {\n        this._nextMessageId = 1;\n      }\n    }\n  }, {\n    key: \"_deframeMessages\",\n    value: function _deframeMessages(data) {\n      var byteArray = new Uint8Array(data);\n\n      if (this.receiveBuffer) {\n        var receiveBufferLength = this.receiveBuffer.length;\n        var newData = new Uint8Array(receiveBufferLength + byteArray.length);\n        newData.set(this.receiveBuffer);\n        newData.set(byteArray, receiveBufferLength);\n        byteArray = newData;\n        this.receiveBuffer = null;\n      }\n\n      try {\n        var offset = 0;\n        var messages = [];\n\n        while (offset < byteArray.length) {\n          var result = (0, _util.decodeMessage)(byteArray, offset);\n          var wireMessage = result[0];\n          offset = result[1];\n\n          if (wireMessage) {\n            messages.push(wireMessage);\n          } else {\n            break;\n          }\n        }\n\n        if (offset < byteArray.length) {\n          this.receiveBuffer = byteArray.subarray(offset);\n        }\n\n        return messages;\n      } catch (error) {\n        this._disconnected(_constants.ERROR.INTERNAL_ERROR.code, (0, _util.format)(_constants.ERROR.INTERNAL_ERROR, [error.message, error.stack.toString()]));\n      }\n    }\n  }, {\n    key: \"_handleMessage\",\n    value: function _handleMessage(wireMessage) {\n      var _this5 = this;\n\n      this._trace('Client._handleMessage', wireMessage);\n\n      var connectOptions = this.connectOptions;\n      (0, _util.invariant)(connectOptions, (0, _util.format)(_constants.ERROR.INVALID_STATE, ['_handleMessage invoked but connectOptions not set']));\n\n      try {\n        if (wireMessage instanceof _PublishMessage.default) {\n          this._receivePublish(wireMessage);\n\n          return;\n        }\n\n        var sentMessage, receivedMessage, messageIdentifier;\n\n        switch (wireMessage.type) {\n          case _constants.MESSAGE_TYPE.CONNACK:\n            clearTimeout(this._connectTimeout);\n\n            if (connectOptions.cleanSession) {\n              Object.keys(this._outboundMessagesInFlight).forEach(function (key) {\n                sentMessage = _this5._outboundMessagesInFlight[key];\n                (0, _util.invariant)(messageIdentifier = sentMessage.messageIdentifier, (0, _util.format)(_constants.ERROR.INVALID_STATE, ['Stored WireMessage with no messageIdentifier']));\n\n                _this5.storage.removeItem('Sent:' + _this5._localKey + messageIdentifier);\n              });\n              this._outboundMessagesInFlight = {};\n              Object.keys(this._receivedMessagesAwaitingAckConfirm).forEach(function (key) {\n                receivedMessage = _this5._receivedMessagesAwaitingAckConfirm[key];\n                (0, _util.invariant)(messageIdentifier = receivedMessage.messageIdentifier, (0, _util.format)(_constants.ERROR.INVALID_STATE, ['Stored WireMessage with no messageIdentifier']));\n\n                _this5.storage.removeItem('Received:' + _this5._localKey + messageIdentifier);\n              });\n              this._receivedMessagesAwaitingAckConfirm = {};\n            }\n\n            if (wireMessage.returnCode === 0) {\n              this.connected = true;\n            } else {\n              this._disconnected(_constants.ERROR.CONNACK_RETURNCODE.code, (0, _util.format)(_constants.ERROR.CONNACK_RETURNCODE, [wireMessage.returnCode, _constants.CONNACK_RC[wireMessage.returnCode]]));\n\n              break;\n            }\n\n            var sequencedMessages = Object.keys(this._outboundMessagesInFlight).map(function (key) {\n              return _this5._outboundMessagesInFlight[key];\n            }).sort(function (a, b) {\n              return (a.sequence || 0) - (b.sequence || 0);\n            });\n            sequencedMessages.forEach(function (sequencedMessage) {\n              (0, _util.invariant)(messageIdentifier = sequencedMessage.messageIdentifier, (0, _util.format)(_constants.ERROR.INVALID_STATE, ['PUBREL WireMessage with no messageIdentifier']));\n\n              if (sequencedMessage instanceof _PublishMessage.default && sequencedMessage.pubRecReceived) {\n                _this5._scheduleMessage(new _WireMessage.default(_constants.MESSAGE_TYPE.PUBREL, {\n                  messageIdentifier: messageIdentifier\n                }));\n              } else {\n                _this5._scheduleMessage(sequencedMessage);\n              }\n            });\n            connectOptions.onSuccess && connectOptions.onSuccess();\n\n            this._process_queue();\n\n            break;\n\n          case _constants.MESSAGE_TYPE.PUBACK:\n            (0, _util.invariant)(messageIdentifier = wireMessage.messageIdentifier, (0, _util.format)(_constants.ERROR.INVALID_STATE, ['PUBACK WireMessage with no messageIdentifier']));\n            sentMessage = this._outboundMessagesInFlight[messageIdentifier.toString()];\n\n            if (sentMessage) {\n              delete this._outboundMessagesInFlight[messageIdentifier.toString()];\n              this.storage.removeItem('Sent:' + this._localKey + messageIdentifier);\n\n              if (this.onMessageDelivered && sentMessage instanceof _PublishMessage.default) {\n                this.onMessageDelivered(sentMessage.payloadMessage);\n              }\n            }\n\n            break;\n\n          case _constants.MESSAGE_TYPE.PUBREC:\n            (0, _util.invariant)(messageIdentifier = wireMessage.messageIdentifier, (0, _util.format)(_constants.ERROR.INVALID_STATE, ['PUBREC WireMessage with no messageIdentifier']));\n            sentMessage = this._outboundMessagesInFlight[messageIdentifier.toString()];\n\n            if (sentMessage && sentMessage instanceof _PublishMessage.default) {\n              sentMessage.pubRecReceived = true;\n              var pubRelMessage = new _WireMessage.default(_constants.MESSAGE_TYPE.PUBREL, {\n                messageIdentifier: messageIdentifier\n              });\n              this.store('Sent:', sentMessage);\n\n              this._scheduleMessage(pubRelMessage);\n            }\n\n            break;\n\n          case _constants.MESSAGE_TYPE.PUBREL:\n            (0, _util.invariant)(messageIdentifier = wireMessage.messageIdentifier, (0, _util.format)(_constants.ERROR.INVALID_STATE, ['PUBREL WireMessage with no messageIdentifier']));\n            receivedMessage = this._receivedMessagesAwaitingAckConfirm[messageIdentifier.toString()];\n            this.storage.removeItem('Received:' + this._localKey + messageIdentifier);\n\n            if (receivedMessage && receivedMessage instanceof _PublishMessage.default) {\n              this._receiveMessage(receivedMessage);\n\n              delete this._receivedMessagesAwaitingAckConfirm[messageIdentifier.toString()];\n            }\n\n            var pubCompMessage = new _WireMessage.default(_constants.MESSAGE_TYPE.PUBCOMP, {\n              messageIdentifier: messageIdentifier\n            });\n\n            this._scheduleMessage(pubCompMessage);\n\n            break;\n\n          case _constants.MESSAGE_TYPE.PUBCOMP:\n            (0, _util.invariant)(messageIdentifier = wireMessage.messageIdentifier, (0, _util.format)(_constants.ERROR.INVALID_STATE, ['PUBCOMP WireMessage with no messageIdentifier']));\n            sentMessage = this._outboundMessagesInFlight[messageIdentifier.toString()];\n            delete this._outboundMessagesInFlight[messageIdentifier.toString()];\n            this.storage.removeItem('Sent:' + this._localKey + messageIdentifier);\n\n            if (this.onMessageDelivered && sentMessage instanceof _PublishMessage.default) {\n              this.onMessageDelivered(sentMessage.payloadMessage);\n            }\n\n            break;\n\n          case _constants.MESSAGE_TYPE.SUBACK:\n            (0, _util.invariant)(messageIdentifier = wireMessage.messageIdentifier, (0, _util.format)(_constants.ERROR.INVALID_STATE, ['SUBACK WireMessage with no messageIdentifier']));\n            sentMessage = this._outboundMessagesInFlight[messageIdentifier.toString()];\n\n            if (sentMessage) {\n              if (sentMessage.timeOut) {\n                clearTimeout(sentMessage.timeOut);\n              }\n\n              (0, _util.invariant)(wireMessage.returnCode instanceof Uint8Array, (0, _util.format)(_constants.ERROR.INVALID_STATE, ['SUBACK WireMessage with invalid returnCode']));\n\n              if (wireMessage.returnCode[0] === 0x80) {\n                if (sentMessage instanceof _WireMessage.default && sentMessage.onFailure) {\n                  sentMessage.onFailure(new Error('Suback error'));\n                }\n              } else if (sentMessage instanceof _WireMessage.default && sentMessage.subAckReceived) {\n                sentMessage.subAckReceived(wireMessage.returnCode[0]);\n              }\n\n              delete this._outboundMessagesInFlight[messageIdentifier.toString()];\n            }\n\n            break;\n\n          case _constants.MESSAGE_TYPE.UNSUBACK:\n            (0, _util.invariant)(messageIdentifier = wireMessage.messageIdentifier, (0, _util.format)(_constants.ERROR.INVALID_STATE, ['UNSUBACK WireMessage with no messageIdentifier']));\n            sentMessage = this._outboundMessagesInFlight[messageIdentifier.toString()];\n\n            if (sentMessage && sentMessage instanceof _WireMessage.default && sentMessage.type === _constants.MESSAGE_TYPE.UNSUBSCRIBE) {\n              if (sentMessage.timeOut) {\n                clearTimeout(sentMessage.timeOut);\n              }\n\n              sentMessage.unSubAckReceived && sentMessage.unSubAckReceived();\n              delete this._outboundMessagesInFlight[messageIdentifier.toString()];\n            }\n\n            break;\n\n          case _constants.MESSAGE_TYPE.PINGRESP:\n            break;\n\n          case _constants.MESSAGE_TYPE.DISCONNECT:\n            this._disconnected(_constants.ERROR.INVALID_MQTT_MESSAGE_TYPE.code, (0, _util.format)(_constants.ERROR.INVALID_MQTT_MESSAGE_TYPE, [wireMessage.type]));\n\n            break;\n\n          default:\n            this._disconnected(_constants.ERROR.INVALID_MQTT_MESSAGE_TYPE.code, (0, _util.format)(_constants.ERROR.INVALID_MQTT_MESSAGE_TYPE, [wireMessage.type]));\n\n        }\n      } catch (error) {\n        this._disconnected(_constants.ERROR.INTERNAL_ERROR.code, (0, _util.format)(_constants.ERROR.INTERNAL_ERROR, [error.message, error.stack.toString()]));\n      }\n    }\n  }, {\n    key: \"_socketSend\",\n    value: function _socketSend(wireMessage) {\n      this._trace('Client._socketSend', wireMessage);\n\n      this.socket && this.socket.send(wireMessage.encode());\n      this.sendPinger && this.sendPinger.reset();\n    }\n  }, {\n    key: \"_receivePublish\",\n    value: function _receivePublish(wireMessage) {\n      var payloadMessage = wireMessage.payloadMessage,\n          messageIdentifier = wireMessage.messageIdentifier;\n      (0, _util.invariant)(payloadMessage, (0, _util.format)(_constants.ERROR.INVALID_STATE, ['PUBLISH WireMessage with no payloadMessage']));\n\n      switch (payloadMessage.qos) {\n        case 0:\n          this._receiveMessage(wireMessage);\n\n          break;\n\n        case 1:\n          (0, _util.invariant)(messageIdentifier, (0, _util.format)(_constants.ERROR.INVALID_STATE, ['QoS 1 WireMessage with no messageIdentifier']));\n\n          this._scheduleMessage(new _WireMessage.default(_constants.MESSAGE_TYPE.PUBACK, {\n            messageIdentifier: messageIdentifier\n          }));\n\n          this._receiveMessage(wireMessage);\n\n          break;\n\n        case 2:\n          (0, _util.invariant)(messageIdentifier, (0, _util.format)(_constants.ERROR.INVALID_STATE, ['QoS 2 WireMessage with no messageIdentifier']));\n          this._receivedMessagesAwaitingAckConfirm[messageIdentifier.toString()] = wireMessage;\n          this.store('Received:', wireMessage);\n\n          this._scheduleMessage(new _WireMessage.default(_constants.MESSAGE_TYPE.PUBREC, {\n            messageIdentifier: messageIdentifier\n          }));\n\n          break;\n\n        default:\n          throw Error('Invaild qos=' + payloadMessage.qos);\n      }\n    }\n  }, {\n    key: \"_receiveMessage\",\n    value: function _receiveMessage(wireMessage) {\n      if (this.onMessageArrived) {\n        this.onMessageArrived(wireMessage.payloadMessage);\n      }\n    }\n  }, {\n    key: \"_disconnected\",\n    value: function _disconnected(errorCode, errorText) {\n      this._trace('Client._disconnected', errorCode, errorText);\n\n      this.sendPinger && this.sendPinger.cancel();\n\n      if (this._connectTimeout) {\n        clearTimeout(this._connectTimeout);\n      }\n\n      this._messagesAwaitingDispatch = [];\n\n      if (this.socket) {\n        this.socket.onopen = function () {\n          return null;\n        };\n\n        this.socket.onmessage = function () {\n          return null;\n        };\n\n        this.socket.onerror = function () {\n          return null;\n        };\n\n        this.socket.onclose = function () {\n          return null;\n        };\n\n        if (this.socket.readyState === 1) {\n          this.socket.close();\n        }\n\n        this.socket = null;\n      }\n\n      if (errorCode === undefined) {\n        errorCode = _constants.ERROR.OK.code;\n        errorText = (0, _util.format)(_constants.ERROR.OK);\n      }\n\n      if (this.connected) {\n        this.connected = false;\n        this.onConnectionLost && this.onConnectionLost({\n          errorCode: errorCode,\n          errorMessage: errorText\n        });\n      } else {\n        if (this.connectOptions && this.connectOptions.onFailure) {\n          this.connectOptions.onFailure(new Error(errorText));\n        }\n      }\n    }\n  }, {\n    key: \"_trace\",\n    value: function _trace() {\n      var traceFunction = this.traceFunction;\n\n      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n        args[_key] = arguments[_key];\n      }\n\n      if (traceFunction) {\n        traceFunction({\n          severity: 'Debug',\n          message: args.map(function (a) {\n            return JSON.stringify(a);\n          }).join('')\n        });\n      }\n\n      if (this._traceBuffer !== null) {\n        for (var i = 0, max = args.length; i < max; i++) {\n          if (this._traceBuffer.length === this._MAX_TRACE_ENTRIES) {\n            this._traceBuffer.shift();\n          }\n\n          if (i === 0 || typeof args[i] === 'undefined') {\n            this._traceBuffer.push(args[i]);\n          } else {\n            this._traceBuffer.push('  ' + JSON.stringify(args[i]));\n          }\n        }\n      }\n    }\n  }]);\n  return ClientImplementation;\n}();\n\nvar _default = ClientImplementation;\nexports.default = _default;","map":{"version":3,"sources":["C:/Users/venkatesh.devireddy/Projects/IoT_Central_CPM/node_modules/react-native-azure-iotcentral-client/node_modules/react-native-paho-mqtt/src/ClientImplementation.js"],"names":["ClientImplementation","uri","clientId","storage","ws","connected","maxOutboundInFlight","_msg_queue","sendPinger","receiveBuffer","_traceBuffer","_MAX_TRACE_ENTRIES","_messagesAwaitingDispatch","_outboundMessagesInFlight","_receivedMessagesAwaitingAckConfirm","_nextMessageId","_sequence","window","WebSocket","Error","ERROR","UNSUPPORTED","localStorage","ArrayBuffer","_trace","webSocket","_localKey","Object","keys","forEach","key","indexOf","restore","connectOptions","maskedCopy","password","socket","INVALID_STATE","mqttVersion","binaryType","onopen","willMessage","userName","cleanSession","keepAliveInterval","wireMessage","ConnectMessage","options","delay","setTimeout","send","encode","onmessage","event","data","messages","_deframeMessages","message","_handleMessage","onerror","error","_disconnected","SOCKET_ERROR","code","onclose","SOCKET_CLOSE","Pinger","timeout","_connectTimeout","CONNECT_TIMEOUT","filter","subscribeOptions","WireMessage","MESSAGE_TYPE","SUBSCRIBE","topics","requestedQos","qos","onSuccess","subAckReceived","grantedQos","onFailure","timeOut","SUBSCRIBE_TIMEOUT","_requires_ack","_scheduleMessage","unsubscribeOptions","UNSUBSCRIBE","unSubAckReceived","UNSUBSCRIBE_TIMEOUT","PublishMessage","onMessageDelivered","onDispatched","payloadMessage","DISCONNECT","Date","length","push","_process_queue","prefix","messageIdentifier","storedMessage","type","version","PUBLISH","pubRecReceived","hex","messageBytes","payloadBytes","i","toString","payloadHex","destinationName","duplicate","retained","sequence","undefined","INVALID_STORED_DATA","setItem","JSON","stringify","value","getItem","parse","buffer","byteStream","Uint8Array","x","parseInt","substring","Message","shift","reset","messageCount","store","byteArray","receiveBufferLength","newData","set","offset","result","subarray","INTERNAL_ERROR","stack","_receivePublish","sentMessage","receivedMessage","CONNACK","clearTimeout","removeItem","returnCode","CONNACK_RETURNCODE","CONNACK_RC","sequencedMessages","map","sort","a","b","sequencedMessage","PUBREL","PUBACK","PUBREC","pubRelMessage","_receiveMessage","pubCompMessage","PUBCOMP","SUBACK","UNSUBACK","PINGRESP","INVALID_MQTT_MESSAGE_TYPE","onMessageArrived","errorCode","errorText","cancel","readyState","close","OK","onConnectionLost","errorMessage","traceFunction","args","severity","join","max"],"mappings":"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","sourcesContent":["/** @flow */\n\nimport Message from './Message';\nimport { decodeMessage, format, invariant } from './util';\nimport { CONNACK_RC, ERROR, MESSAGE_TYPE } from './constants';\nimport Pinger from './Pinger';\nimport WireMessage from './WireMessage';\nimport PublishMessage from './PublishMessage';\nimport ConnectMessage from './ConnectMessage';\n\ntype ConnectOptions = {\n  timeout?: number,\n  delay?: number,\n  mqttVersion: 3 | 4,\n  keepAliveInterval: number,\n  onSuccess: ?() => void,\n  onFailure: ?(Error) => void,\n  userName?: string,\n  password?: string,\n  willMessage: ?Message,\n  cleanSession: boolean\n}\n\ntype Storage = Object & { setItem: (key: string, item: any) => void, getItem: (key: string) => any };\n\n/*\n * Internal implementation of the Websockets MQTT V3.1/V4 client.\n */\nclass ClientImplementation {\n\n  uri: string;\n  clientId: string;\n  storage: Storage;\n  webSocket: Class<WebSocket>;\n  socket: ?WebSocket;\n\n  // We have received a CONNACK and not subsequently disconnected\n  connected = false;\n\n  // The largest permitted message ID, effectively number of in-flight outbound messages.\n  // Must be <=65536, the maximum permitted by the protocol\n  maxOutboundInFlight = 65536;\n  connectOptions: ?ConnectOptions;\n  onConnectionLost: ?Function;\n  onMessageDelivered: ?Function;\n  onMessageArrived: ?Function;\n  traceFunction: ?Function;\n  _msg_queue = null;\n  _connectTimeout: ?number;\n  /* The sendPinger monitors how long we allow before we send data to prove to the server that we are alive. */\n  sendPinger = null;\n\n  receiveBuffer: ?Uint8Array = null;\n\n  _traceBuffer = null;\n  _MAX_TRACE_ENTRIES = 100;\n\n  // Internal queue of messages to be sent, in sending order.\n  _messagesAwaitingDispatch: (WireMessage | PublishMessage)[] = [];\n\n  // Messages we have sent and are expecting a response for, indexed by their respective message ids.\n  _outboundMessagesInFlight: { [key: string]: WireMessage | PublishMessage } = {};\n\n  // Messages we have received and acknowleged and are expecting a confirm message for indexed by their respective message ids.\n  _receivedMessagesAwaitingAckConfirm: { [key: string]: WireMessage | PublishMessage } = {};\n\n  // Unique identifier for outbound messages, incrementing counter as messages are sent.\n  _nextMessageId: number = 1;\n\n  // Used to determine the transmission sequence of stored sent messages.\n  _sequence: number = 0;\n\n  // Local storage keys are qualified with this.\n  _localKey: string;\n\n  /**\n   *\n   * @param {string} [uri] the FQDN (with protocol and path suffix) of the host\n   * @param {string} [clientId] the MQ client identifier.\n   * @param {object} [storage] object implementing getItem, setItem, removeItem in a manner compatible with localStorage\n   * @param {object} [ws] object implementing the W3C websockets spec\n   */\n  constructor(uri: string, clientId: string, storage?: Object, ws?: Class<WebSocket>) {\n    // Check dependencies are satisfied in this browser.\n    if (!ws && !(window && window.WebSocket)) {\n      throw new Error(format(ERROR.UNSUPPORTED, ['WebSocket']));\n    }\n    if (!storage && !(window && window.localStorage)) {\n      throw new Error(format(ERROR.UNSUPPORTED, ['localStorage']));\n    }\n\n    if (!(window && window.ArrayBuffer)) {\n      throw new Error(format(ERROR.UNSUPPORTED, ['ArrayBuffer']));\n    }\n    this._trace('Client', uri, clientId);\n\n    this.uri = uri;\n    this.clientId = clientId;\n    this.storage = storage || window.localStorage;\n    this.webSocket = ws || window.WebSocket;\n\n    // Local storagekeys are qualified with the following string.\n    // The conditional inclusion of path in the key is for backward\n    // compatibility to when the path was not configurable and assumed to\n    // be /mqtt\n    this._localKey = uri + ':' + clientId + ':';\n\n\n    // Load the local state, if any, from the saved version, only restore state relevant to this client.\n    Object.keys(this.storage).forEach(key => {\n      if (key.indexOf('Sent:' + this._localKey) === 0 || key.indexOf('Received:' + this._localKey) === 0) {\n        this.restore(key);\n      }\n    });\n  }\n\n\n  connect(connectOptions: ConnectOptions) {\n    const maskedCopy = { ...connectOptions };\n    if (maskedCopy.password) {\n      maskedCopy.password = 'REDACTED';\n    }\n    this._trace('Client.connect', maskedCopy, this.socket, this.connected);\n\n    if (this.connected) {\n      throw new Error(format(ERROR.INVALID_STATE, ['already connected']));\n    }\n    if (this.socket) {\n      throw new Error(format(ERROR.INVALID_STATE, ['already connected']));\n    }\n\n    this.connectOptions = connectOptions;\n    this.connected = false;\n    this.socket = new this.webSocket(this.uri, ['mqtt' + (connectOptions.mqttVersion === 3 ? 'v3.1' : '')]);\n    this.socket.binaryType = 'arraybuffer';\n\n    // When the socket is open, this client will send the CONNECT WireMessage using the saved parameters.\n    this.socket.onopen = () => {\n      const { willMessage, mqttVersion, userName, password, cleanSession, keepAliveInterval } = connectOptions;\n      // Send the CONNECT message object.\n\n      const wireMessage = new ConnectMessage({\n        cleanSession,\n        userName,\n        password,\n        mqttVersion,\n        willMessage,\n        keepAliveInterval,\n        clientId: this.clientId\n      });\n\n      this._trace('socket.send', { ...wireMessage, options: maskedCopy });\n\n      this.socket && (this.socket.onopen = () => null);\n      let delay = 0;\n      if (connectOptions.delay) {\n        delay = connectOptions.delay * 1000;\n      }\n      setTimeout(() => {\n        this.socket && (this.socket.send(wireMessage.encode()));\n      }, delay);\n    };\n\n    this.socket.onmessage = (event) => {\n      this._trace('socket.onmessage', event.data);\n      const messages = this._deframeMessages(((event.data: any): ArrayBuffer));\n      messages && messages.forEach(message => this._handleMessage(message));\n    };\n    this.socket.onerror = (error: { data?: string }) =>\n      this._disconnected(ERROR.SOCKET_ERROR.code, format(ERROR.SOCKET_ERROR, [error.data || ' Unknown socket error']));\n    this.socket.onclose = () => this._disconnected(ERROR.SOCKET_CLOSE.code, format(ERROR.SOCKET_CLOSE));\n\n    if (connectOptions.keepAliveInterval > 0) {\n      //Cast this to any to deal with flow/IDE bug: https://github.com/facebook/flow/issues/2235#issuecomment-239357626\n      this.sendPinger = new Pinger((this: any), connectOptions.keepAliveInterval);\n    }\n\n    if (connectOptions.timeout) {\n      this._connectTimeout = setTimeout(() => {\n        this._disconnected(ERROR.CONNECT_TIMEOUT.code, format(ERROR.CONNECT_TIMEOUT));\n      }, connectOptions.timeout);\n    }\n  }\n\n  subscribe(filter: string, subscribeOptions: { onSuccess: ({ grantedQos: number }) => void, onFailure: (Error) => void, qos: 0 | 1 | 2, timeout: number }) {\n    this._trace('Client.subscribe', filter, subscribeOptions);\n\n    if (!this.connected) {\n      throw new Error(format(ERROR.INVALID_STATE, ['not connected']));\n    }\n\n    const wireMessage = new WireMessage(MESSAGE_TYPE.SUBSCRIBE);\n    wireMessage.topics = [filter];\n    wireMessage.requestedQos = [subscribeOptions.qos || 0];\n\n    if (subscribeOptions.onSuccess) {\n      wireMessage.subAckReceived = function (grantedQos) {\n        subscribeOptions.onSuccess({ grantedQos: grantedQos });\n      };\n    }\n\n    if (subscribeOptions.onFailure) {\n      wireMessage.onFailure = subscribeOptions.onFailure;\n    }\n\n    if (subscribeOptions.timeout && subscribeOptions.onFailure) {\n      wireMessage.timeOut = setTimeout(() => {\n        subscribeOptions.onFailure(new Error(format(ERROR.SUBSCRIBE_TIMEOUT)));\n      }, subscribeOptions.timeout);\n    }\n\n    // All subscriptions return a SUBACK.\n    this._requires_ack(wireMessage);\n    this._scheduleMessage(wireMessage);\n  }\n\n  /** @ignore */\n  unsubscribe(filter: string, unsubscribeOptions: { onSuccess: () => void, onFailure: (Error) => void, timeout: number }) {\n    this._trace('Client.unsubscribe', filter, unsubscribeOptions);\n\n    if (!this.connected) {\n      throw new Error(format(ERROR.INVALID_STATE, ['not connected']));\n    }\n\n    const wireMessage = new WireMessage(MESSAGE_TYPE.UNSUBSCRIBE);\n    wireMessage.topics = [filter];\n\n    if (unsubscribeOptions.onSuccess) {\n      wireMessage.unSubAckReceived = function () {\n        unsubscribeOptions.onSuccess();\n      };\n    }\n    if (unsubscribeOptions.timeout) {\n      wireMessage.timeOut = setTimeout(() => {\n        unsubscribeOptions.onFailure(new Error(format(ERROR.UNSUBSCRIBE_TIMEOUT)));\n      }, unsubscribeOptions.timeout);\n    }\n\n    // All unsubscribes return a SUBACK.\n    this._requires_ack(wireMessage);\n    this._scheduleMessage(wireMessage);\n  }\n\n  send(message: Message) {\n    this._trace('Client.send', message);\n\n    if (!this.connected) {\n      throw new Error(format(ERROR.INVALID_STATE, ['not connected']));\n    }\n\n    const wireMessage = new PublishMessage(message);\n\n    if (message.qos > 0) {\n      this._requires_ack(wireMessage);\n    } else if (this.onMessageDelivered) {\n      const onMessageDelivered = this.onMessageDelivered;\n      wireMessage.onDispatched = () => onMessageDelivered(wireMessage.payloadMessage);\n    }\n    this._scheduleMessage(wireMessage);\n  }\n\n  disconnect() {\n    this._trace('Client.disconnect');\n\n    if (!this.socket) {\n      throw new Error(format(ERROR.INVALID_STATE, ['not connecting or connected']));\n    }\n\n    const wireMessage = new WireMessage(MESSAGE_TYPE.DISCONNECT);\n\n    // Run the disconnected call back as soon as the message has been sent,\n    // in case of a failure later on in the disconnect processing.\n    // as a consequence, the _disconnected call back may be run several times.\n    wireMessage.onDispatched = () => {\n      this._disconnected();\n    };\n\n    this._scheduleMessage(wireMessage);\n  }\n\n  getTraceLog() {\n    if (this._traceBuffer !== null) {\n      this._trace('Client.getTraceLog', new Date());\n      this._trace('Client.getTraceLog in flight messages', Object.keys(this._outboundMessagesInFlight).length);\n      Object.keys(this._outboundMessagesInFlight).forEach((key) => {\n        this._trace('_outboundMessagesInFlight ', key, this._outboundMessagesInFlight[key]);\n      });\n      Object.keys(this._receivedMessagesAwaitingAckConfirm).forEach((key) => {\n        this._trace('_receivedMessagesAwaitingAckConfirm ', key, this._receivedMessagesAwaitingAckConfirm[key]);\n      });\n      return this._traceBuffer;\n    }\n  }\n\n  startTrace() {\n    if (this._traceBuffer === null) {\n      this._traceBuffer = [];\n    }\n    this._trace('Client.startTrace', new Date());\n  }\n\n  stopTrace() {\n    this._traceBuffer = null;\n  }\n\n\n  // Schedule a new message to be sent over the WebSockets\n  // connection. CONNECT messages cause WebSocket connection\n  // to be started. All other messages are queued internally\n  // until this has happened. When WS connection starts, process\n  // all outstanding messages.\n  _scheduleMessage(message: WireMessage | PublishMessage) {\n    this._messagesAwaitingDispatch.push(message);\n    // Process outstanding messages in the queue if we have an  open socket, and have received CONNACK.\n    if (this.connected) {\n      this._process_queue();\n    }\n  }\n\n  store(prefix: string, wireMessage: PublishMessage) {\n    const messageIdentifier = wireMessage.messageIdentifier;\n    invariant(messageIdentifier, format(ERROR.INVALID_STATE, ['Cannot store a WireMessage with no messageIdentifier']));\n    const storedMessage: any = { type: wireMessage.type, messageIdentifier, version: 1 };\n\n    switch (wireMessage.type) {\n      case MESSAGE_TYPE.PUBLISH:\n        const payloadMessage = wireMessage.payloadMessage;\n        invariant(payloadMessage, format(ERROR.INVALID_STATE, ['PUBLISH WireMessage with no payloadMessage']));\n        if (wireMessage.pubRecReceived) {\n          storedMessage.pubRecReceived = true;\n        }\n\n        // Convert the payload to a hex string.\n        storedMessage.payloadMessage = {};\n        let hex = '';\n        const messageBytes = payloadMessage.payloadBytes;\n        for (let i = 0; i < messageBytes.length; i++) {\n          if (messageBytes[i] <= 0xF) {\n            hex = hex + '0' + messageBytes[i].toString(16);\n          } else {\n            hex = hex + messageBytes[i].toString(16);\n          }\n        }\n        storedMessage.payloadMessage.payloadHex = hex;\n\n        storedMessage.payloadMessage.qos = payloadMessage.qos;\n        storedMessage.payloadMessage.destinationName = payloadMessage.destinationName;\n        if (payloadMessage.duplicate) {\n          storedMessage.payloadMessage.duplicate = true;\n        }\n        if (payloadMessage.retained) {\n          storedMessage.payloadMessage.retained = true;\n        }\n\n        // Add a sequence number to sent messages.\n        if (prefix.indexOf('Sent:') === 0) {\n          if (wireMessage.sequence === undefined) {\n            wireMessage.sequence = ++this._sequence;\n          }\n          storedMessage.sequence = wireMessage.sequence;\n        }\n        break;\n\n      default:\n        throw Error(format(ERROR.INVALID_STORED_DATA, [prefix + this._localKey + messageIdentifier, storedMessage]));\n    }\n    this.storage.setItem(prefix + this._localKey + messageIdentifier, JSON.stringify(storedMessage));\n  }\n\n  restore(key: string) {\n    const value = this.storage.getItem(key);\n    const storedMessage = JSON.parse(value);\n\n    let wireMessage: PublishMessage;\n\n    switch (storedMessage.type) {\n      case MESSAGE_TYPE.PUBLISH:\n        // Replace the payload message with a Message object.\n        let hex = storedMessage.payloadMessage.payloadHex;\n        const buffer = new ArrayBuffer((hex.length) / 2);\n        const byteStream = new Uint8Array(buffer);\n        let i = 0;\n        while (hex.length >= 2) {\n          const x = parseInt(hex.substring(0, 2), 16);\n          hex = hex.substring(2, hex.length);\n          byteStream[i++] = x;\n        }\n        const payloadMessage = new Message(byteStream);\n\n        payloadMessage.qos = storedMessage.payloadMessage.qos;\n        payloadMessage.destinationName = storedMessage.payloadMessage.destinationName;\n        if (storedMessage.payloadMessage.duplicate) {\n          payloadMessage.duplicate = true;\n        }\n        if (storedMessage.payloadMessage.retained) {\n          payloadMessage.retained = true;\n        }\n        wireMessage = new PublishMessage(payloadMessage, storedMessage.messageIdentifier);\n\n        break;\n\n      default:\n        throw Error(format(ERROR.INVALID_STORED_DATA, [key, value]));\n    }\n\n    if (key.indexOf('Sent:' + this._localKey) === 0) {\n      wireMessage.payloadMessage.duplicate = true;\n      invariant(wireMessage.messageIdentifier, format(ERROR.INVALID_STATE, ['Stored WireMessage with no messageIdentifier']));\n      this._outboundMessagesInFlight[wireMessage.messageIdentifier.toString()] = wireMessage;\n    } else if (key.indexOf('Received:' + this._localKey) === 0) {\n      invariant(wireMessage.messageIdentifier, format(ERROR.INVALID_STATE, ['Stored WireMessage with no messageIdentifier']));\n      this._receivedMessagesAwaitingAckConfirm[wireMessage.messageIdentifier.toString()] = wireMessage;\n    }\n  }\n\n  _process_queue() {\n    // Process messages in order they were added\n    // Send all queued messages down socket connection\n    const socket = this.socket;\n\n    // Consume each message and remove it from the queue\n    let wireMessage;\n    while ((wireMessage = this._messagesAwaitingDispatch.shift())) {\n      this._trace('Client._socketSend', wireMessage);\n      socket && socket.send(wireMessage.encode());\n      wireMessage.onDispatched && wireMessage.onDispatched();\n    }\n\n    this.sendPinger && this.sendPinger.reset();\n  }\n\n  /**\n   * Expect an ACK response for this message. Add message to the set of in progress\n   * messages and set an unused identifier in this message.\n   * @ignore\n   */\n  _requires_ack(wireMessage: WireMessage | PublishMessage) {\n    const messageCount = Object.keys(this._outboundMessagesInFlight).length;\n    if (messageCount > this.maxOutboundInFlight) {\n      throw Error('Too many messages:' + messageCount);\n    }\n\n    while (this._outboundMessagesInFlight[this._nextMessageId.toString()] !== undefined) {\n      this._nextMessageId++;\n    }\n    wireMessage.messageIdentifier = this._nextMessageId;\n    this._outboundMessagesInFlight[wireMessage.messageIdentifier.toString()] = wireMessage;\n    if (wireMessage instanceof PublishMessage) {\n      this.store('Sent:', wireMessage);\n    }\n    if (this._nextMessageId === this.maxOutboundInFlight) {\n      // Next time we will search for the first unused ID up from 1\n      this._nextMessageId = 1;\n    }\n  }\n\n  _deframeMessages(data: ArrayBuffer): ?Array<(WireMessage | PublishMessage)> {\n    let byteArray = new Uint8Array(data);\n    if (this.receiveBuffer) {\n      const receiveBufferLength = this.receiveBuffer.length;\n      const newData = new Uint8Array(receiveBufferLength + byteArray.length);\n      newData.set(this.receiveBuffer);\n      newData.set(byteArray, receiveBufferLength);\n      byteArray = newData;\n      this.receiveBuffer = null;\n    }\n    try {\n      let offset = 0;\n      let messages: (WireMessage | PublishMessage)[] = [];\n      while (offset < byteArray.length) {\n        const result = decodeMessage(byteArray, offset);\n        const wireMessage = result[0];\n        offset = result[1];\n        if (wireMessage) {\n          messages.push(wireMessage);\n        } else {\n          break;\n        }\n      }\n      if (offset < byteArray.length) {\n        this.receiveBuffer = byteArray.subarray(offset);\n      }\n      return messages;\n    } catch (error) {\n      this._disconnected(ERROR.INTERNAL_ERROR.code, format(ERROR.INTERNAL_ERROR, [error.message, error.stack.toString()]));\n    }\n  }\n\n  _handleMessage(wireMessage: WireMessage | PublishMessage) {\n\n    this._trace('Client._handleMessage', wireMessage);\n    const connectOptions = this.connectOptions;\n    invariant(connectOptions, format(ERROR.INVALID_STATE, ['_handleMessage invoked but connectOptions not set']));\n\n    try {\n      if (wireMessage instanceof PublishMessage) {\n        this._receivePublish(wireMessage);\n        return;\n      }\n\n      let sentMessage: WireMessage | PublishMessage, receivedMessage: WireMessage | PublishMessage, messageIdentifier;\n\n      switch (wireMessage.type) {\n        case MESSAGE_TYPE.CONNACK:\n          clearTimeout(this._connectTimeout);\n\n          // If we have started using clean session then clear up the local state.\n          if (connectOptions.cleanSession) {\n            Object.keys(this._outboundMessagesInFlight).forEach((key) => {\n              sentMessage = this._outboundMessagesInFlight[key];\n              invariant(messageIdentifier = sentMessage.messageIdentifier, format(ERROR.INVALID_STATE, ['Stored WireMessage with no messageIdentifier']));\n              this.storage.removeItem('Sent:' + this._localKey + messageIdentifier);\n            });\n            this._outboundMessagesInFlight = {};\n\n            Object.keys(this._receivedMessagesAwaitingAckConfirm).forEach((key) => {\n              receivedMessage = this._receivedMessagesAwaitingAckConfirm[key];\n              invariant(messageIdentifier = receivedMessage.messageIdentifier, format(ERROR.INVALID_STATE, ['Stored WireMessage with no messageIdentifier']));\n              this.storage.removeItem('Received:' + this._localKey + messageIdentifier);\n            });\n            this._receivedMessagesAwaitingAckConfirm = {};\n          }\n          // Client connected and ready for business.\n          if (wireMessage.returnCode === 0) {\n            this.connected = true;\n          } else {\n            this._disconnected(ERROR.CONNACK_RETURNCODE.code, format(ERROR.CONNACK_RETURNCODE, [wireMessage.returnCode, CONNACK_RC[wireMessage.returnCode]]));\n            break;\n          }\n\n          // Resend messages. Sort sentMessages into the original sent order.\n          const sequencedMessages = Object.keys(this._outboundMessagesInFlight).map(key => this._outboundMessagesInFlight[key]).sort((a, b) => (a.sequence || 0) - (b.sequence || 0));\n\n          sequencedMessages.forEach((sequencedMessage) => {\n            invariant(messageIdentifier = sequencedMessage.messageIdentifier, format(ERROR.INVALID_STATE, ['PUBREL WireMessage with no messageIdentifier']));\n            if (sequencedMessage instanceof PublishMessage && sequencedMessage.pubRecReceived) {\n              this._scheduleMessage(new WireMessage(MESSAGE_TYPE.PUBREL, { messageIdentifier }));\n            } else {\n              this._scheduleMessage(sequencedMessage);\n            }\n          });\n\n          // Execute the connectOptions.onSuccess callback if there is one.\n          connectOptions.onSuccess && connectOptions.onSuccess();\n\n          // Process all queued messages now that the connection is established.\n          this._process_queue();\n          break;\n\n        case MESSAGE_TYPE.PUBACK:\n          invariant(messageIdentifier = wireMessage.messageIdentifier, format(ERROR.INVALID_STATE, ['PUBACK WireMessage with no messageIdentifier']));\n          sentMessage = this._outboundMessagesInFlight[messageIdentifier.toString()];\n          // If this is a re flow of a PUBACK after we have restarted receivedMessage will not exist.\n          if (sentMessage) {\n            delete this._outboundMessagesInFlight[messageIdentifier.toString()];\n            this.storage.removeItem('Sent:' + this._localKey + messageIdentifier);\n            if (this.onMessageDelivered && sentMessage instanceof PublishMessage) {\n              this.onMessageDelivered(sentMessage.payloadMessage);\n            }\n          }\n          break;\n\n        case MESSAGE_TYPE.PUBREC:\n          invariant(messageIdentifier = wireMessage.messageIdentifier, format(ERROR.INVALID_STATE, ['PUBREC WireMessage with no messageIdentifier']));\n          sentMessage = this._outboundMessagesInFlight[messageIdentifier.toString()];\n          // If this is a re flow of a PUBREC after we have restarted receivedMessage will not exist.\n          if (sentMessage && sentMessage instanceof PublishMessage) {\n            sentMessage.pubRecReceived = true;\n            const pubRelMessage = new WireMessage(MESSAGE_TYPE.PUBREL, { messageIdentifier });\n            this.store('Sent:', sentMessage);\n            this._scheduleMessage(pubRelMessage);\n          }\n          break;\n\n        case MESSAGE_TYPE.PUBREL:\n          invariant(messageIdentifier = wireMessage.messageIdentifier, format(ERROR.INVALID_STATE, ['PUBREL WireMessage with no messageIdentifier']));\n          receivedMessage = this._receivedMessagesAwaitingAckConfirm[messageIdentifier.toString()];\n          this.storage.removeItem('Received:' + this._localKey + messageIdentifier);\n          // If this is a re flow of a PUBREL after we have restarted receivedMessage will not exist.\n          if (receivedMessage && receivedMessage instanceof PublishMessage) {\n            this._receiveMessage(receivedMessage);\n            delete this._receivedMessagesAwaitingAckConfirm[messageIdentifier.toString()];\n          }\n          // Always flow PubComp, we may have previously flowed PubComp but the server lost it and restarted.\n          const pubCompMessage = new WireMessage(MESSAGE_TYPE.PUBCOMP, { messageIdentifier });\n          this._scheduleMessage(pubCompMessage);\n          break;\n\n        case MESSAGE_TYPE.PUBCOMP:\n          invariant(messageIdentifier = wireMessage.messageIdentifier, format(ERROR.INVALID_STATE, ['PUBCOMP WireMessage with no messageIdentifier']));\n          sentMessage = this._outboundMessagesInFlight[messageIdentifier.toString()];\n          delete this._outboundMessagesInFlight[messageIdentifier.toString()];\n          this.storage.removeItem('Sent:' + this._localKey + messageIdentifier);\n          if (this.onMessageDelivered && sentMessage instanceof PublishMessage) {\n            this.onMessageDelivered(sentMessage.payloadMessage);\n          }\n          break;\n\n        case MESSAGE_TYPE.SUBACK:\n          invariant(messageIdentifier = wireMessage.messageIdentifier, format(ERROR.INVALID_STATE, ['SUBACK WireMessage with no messageIdentifier']));\n          sentMessage = this._outboundMessagesInFlight[messageIdentifier.toString()];\n          if (sentMessage) {\n            if (sentMessage.timeOut) {\n              clearTimeout(sentMessage.timeOut);\n            }\n            invariant(wireMessage.returnCode instanceof Uint8Array, format(ERROR.INVALID_STATE, ['SUBACK WireMessage with invalid returnCode']));\n            // This will need to be fixed when we add multiple topic support\n            if (wireMessage.returnCode[0] === 0x80) {\n              if ((sentMessage instanceof WireMessage) && sentMessage.onFailure) {\n                sentMessage.onFailure(new Error('Suback error'));\n              }\n            } else if ((sentMessage instanceof WireMessage) && sentMessage.subAckReceived) {\n              sentMessage.subAckReceived(wireMessage.returnCode[0]);\n            }\n            delete this._outboundMessagesInFlight[messageIdentifier.toString()];\n          }\n          break;\n\n        case MESSAGE_TYPE.UNSUBACK:\n          invariant(messageIdentifier = wireMessage.messageIdentifier, format(ERROR.INVALID_STATE, ['UNSUBACK WireMessage with no messageIdentifier']));\n          sentMessage = this._outboundMessagesInFlight[messageIdentifier.toString()];\n          if (sentMessage && (sentMessage instanceof WireMessage) && sentMessage.type === MESSAGE_TYPE.UNSUBSCRIBE) {\n            if (sentMessage.timeOut) {\n              clearTimeout(sentMessage.timeOut);\n            }\n            sentMessage.unSubAckReceived && sentMessage.unSubAckReceived();\n            delete this._outboundMessagesInFlight[messageIdentifier.toString()];\n          }\n\n          break;\n\n        case MESSAGE_TYPE.PINGRESP:\n          // We don't care whether the server is still there (yet)\n          break;\n\n        case MESSAGE_TYPE.DISCONNECT:\n          // Clients do not expect to receive disconnect packets.\n          this._disconnected(ERROR.INVALID_MQTT_MESSAGE_TYPE.code, format(ERROR.INVALID_MQTT_MESSAGE_TYPE, [wireMessage.type]));\n          break;\n\n        default:\n          this._disconnected(ERROR.INVALID_MQTT_MESSAGE_TYPE.code, format(ERROR.INVALID_MQTT_MESSAGE_TYPE, [wireMessage.type]));\n      }\n    } catch (error) {\n      this._disconnected(ERROR.INTERNAL_ERROR.code, format(ERROR.INTERNAL_ERROR, [error.message, error.stack.toString()]));\n    }\n  }\n\n  /** @ignore */\n  _socketSend(wireMessage: WireMessage) {\n    this._trace('Client._socketSend', wireMessage);\n    this.socket && this.socket.send(wireMessage.encode());\n    // We have proved to the server we are alive.\n    this.sendPinger && this.sendPinger.reset();\n  }\n\n  /** @ignore */\n  _receivePublish(wireMessage: PublishMessage) {\n    const { payloadMessage, messageIdentifier } = wireMessage;\n    invariant(payloadMessage, format(ERROR.INVALID_STATE, ['PUBLISH WireMessage with no payloadMessage']));\n    switch (payloadMessage.qos) {\n      case 0:\n        this._receiveMessage(wireMessage);\n        break;\n\n      case 1:\n        invariant(messageIdentifier, format(ERROR.INVALID_STATE, ['QoS 1 WireMessage with no messageIdentifier']));\n        this._scheduleMessage(new WireMessage(MESSAGE_TYPE.PUBACK, { messageIdentifier }));\n        this._receiveMessage(wireMessage);\n        break;\n\n      case 2:\n        invariant(messageIdentifier, format(ERROR.INVALID_STATE, ['QoS 2 WireMessage with no messageIdentifier']));\n        this._receivedMessagesAwaitingAckConfirm[messageIdentifier.toString()] = wireMessage;\n        this.store('Received:', wireMessage);\n        this._scheduleMessage(new WireMessage(MESSAGE_TYPE.PUBREC, { messageIdentifier }));\n        break;\n\n      default:\n        throw Error('Invaild qos=' + payloadMessage.qos);\n    }\n  }\n\n  /** @ignore */\n  _receiveMessage(wireMessage: PublishMessage) {\n    if (this.onMessageArrived) {\n      this.onMessageArrived(wireMessage.payloadMessage);\n    }\n  }\n\n  /**\n   * Client has disconnected either at its own request or because the server\n   * or network disconnected it. Remove all non-durable state.\n   * @param {number} [errorCode] the error number.\n   * @param {string} [errorText] the error text.\n   * @ignore\n   */\n  _disconnected(errorCode?: number, errorText?: string) {\n    this._trace('Client._disconnected', errorCode, errorText);\n\n    this.sendPinger && this.sendPinger.cancel();\n    if (this._connectTimeout) {\n      clearTimeout(this._connectTimeout);\n    }\n    // Clear message buffers.\n    this._messagesAwaitingDispatch = [];\n\n    if (this.socket) {\n      // Cancel all socket callbacks so that they cannot be driven again by this socket.\n      this.socket.onopen = () => null;\n      this.socket.onmessage = () => null;\n      this.socket.onerror = () => null;\n      this.socket.onclose = () => null;\n      if (this.socket.readyState === 1) {\n        this.socket.close();\n      }\n      this.socket = null;\n    }\n\n    if (errorCode === undefined) {\n      errorCode = ERROR.OK.code;\n      errorText = format(ERROR.OK);\n    }\n\n    // Run any application callbacks last as they may attempt to reconnect and hence create a new socket.\n    if (this.connected) {\n      this.connected = false;\n      // Execute the onConnectionLost callback if there is one, and we were connected.\n      this.onConnectionLost && this.onConnectionLost({ errorCode: errorCode, errorMessage: errorText });\n    } else {\n      // Otherwise we never had a connection, so indicate that the connect has failed.\n      if (this.connectOptions && this.connectOptions.onFailure) {\n        this.connectOptions.onFailure(new Error(errorText));\n      }\n    }\n  }\n\n  /** @ignore */\n  _trace(...args: any) {\n    // Pass trace message back to client's callback function\n    const traceFunction = this.traceFunction;\n    if (traceFunction) {\n      traceFunction({ severity: 'Debug', message: args.map(a => JSON.stringify(a)).join('') });\n    }\n\n    //buffer style trace\n    if (this._traceBuffer !== null) {\n      for (let i = 0, max = args.length; i < max; i++) {\n        if (this._traceBuffer.length === this._MAX_TRACE_ENTRIES) {\n          this._traceBuffer.shift();\n        }\n        if (i === 0 || typeof args[i] === 'undefined') {\n          this._traceBuffer.push(args[i]);\n        } else {\n          this._traceBuffer.push('  ' + JSON.stringify(args[i]));\n        }\n      }\n    }\n  }\n}\n\nexport default ClientImplementation;\n"]},"metadata":{},"sourceType":"script"}
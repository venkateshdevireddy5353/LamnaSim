{"ast":null,"code":"var _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _classCallCheck2 = _interopRequireDefault(require(\"@babel/runtime/helpers/classCallCheck\"));\n\nvar _createClass2 = _interopRequireDefault(require(\"@babel/runtime/helpers/createClass\"));\n\nvar _util = require(\"./util\");\n\nvar _constants = require(\"./constants\");\n\nvar _Message = _interopRequireDefault(require(\"./Message\"));\n\nvar _default = function () {\n  function _default(options) {\n    (0, _classCallCheck2.default)(this, _default);\n    this.options = options;\n  }\n\n  (0, _createClass2.default)(_default, [{\n    key: \"encode\",\n    value: function encode() {\n      var options = this.options;\n      var first = (_constants.MESSAGE_TYPE.CONNECT & 0x0f) << 4;\n      var remLength = 0;\n      var willMessagePayloadBytes;\n\n      switch (options.mqttVersion) {\n        case 3:\n          remLength += _constants.MqttProtoIdentifierv3.length + 3;\n          break;\n\n        case 4:\n          remLength += _constants.MqttProtoIdentifierv4.length + 3;\n          break;\n      }\n\n      remLength += (0, _util.lengthOfUTF8)(options.clientId) + 2;\n\n      if (options.willMessage) {\n        willMessagePayloadBytes = options.willMessage.payloadBytes;\n        remLength += (0, _util.lengthOfUTF8)(options.willMessage.destinationName) + 2;\n\n        if (!(willMessagePayloadBytes instanceof Uint8Array)) {\n          willMessagePayloadBytes = new Uint8Array(willMessagePayloadBytes);\n        }\n\n        remLength += willMessagePayloadBytes.byteLength + 2;\n      }\n\n      if (options.userName) {\n        remLength += (0, _util.lengthOfUTF8)(options.userName) + 2;\n\n        if (options.password) {\n          remLength += (0, _util.lengthOfUTF8)(options.password) + 2;\n        }\n      }\n\n      var mbi = (0, _util.encodeMultiByteInteger)(remLength);\n      var pos = mbi.length + 1;\n      var buffer = new ArrayBuffer(remLength + pos);\n      var byteStream = new Uint8Array(buffer);\n      byteStream[0] = first;\n      byteStream.set(mbi, 1);\n\n      switch (options.mqttVersion) {\n        case 3:\n          byteStream.set(_constants.MqttProtoIdentifierv3, pos);\n          pos += _constants.MqttProtoIdentifierv3.length;\n          break;\n\n        case 4:\n          byteStream.set(_constants.MqttProtoIdentifierv4, pos);\n          pos += _constants.MqttProtoIdentifierv4.length;\n          break;\n      }\n\n      var connectFlags = 0;\n\n      if (options.cleanSession) {\n        connectFlags = 0x02;\n      }\n\n      if (options.willMessage) {\n        connectFlags |= 0x04;\n        connectFlags |= options.willMessage.qos << 3;\n\n        if (options.willMessage.retained) {\n          connectFlags |= 0x20;\n        }\n      }\n\n      if (options.userName) {\n        connectFlags |= 0x80;\n      }\n\n      if (options.password) {\n        connectFlags |= 0x40;\n      }\n\n      byteStream[pos++] = connectFlags;\n      pos = (0, _util.writeUint16)(options.keepAliveInterval, byteStream, pos);\n      pos = (0, _util.writeString)(options.clientId, (0, _util.lengthOfUTF8)(options.clientId), byteStream, pos);\n\n      if (options.willMessage) {\n        willMessagePayloadBytes = options.willMessage.payloadBytes;\n        pos = (0, _util.writeString)(options.willMessage.destinationName, (0, _util.lengthOfUTF8)(options.willMessage.destinationName), byteStream, pos);\n        pos = (0, _util.writeUint16)(willMessagePayloadBytes.byteLength, byteStream, pos);\n        byteStream.set(willMessagePayloadBytes, pos);\n        pos += willMessagePayloadBytes.byteLength;\n      }\n\n      if (options.userName) {\n        pos = (0, _util.writeString)(options.userName, (0, _util.lengthOfUTF8)(options.userName), byteStream, pos);\n\n        if (options.password) {\n          (0, _util.writeString)(options.password, (0, _util.lengthOfUTF8)(options.password), byteStream, pos);\n        }\n      }\n\n      return buffer;\n    }\n  }]);\n  return _default;\n}();\n\nexports.default = _default;","map":{"version":3,"sources":["C:/Users/venkatesh.devireddy/Projects/IoT_Central_CPM/node_modules/react-native-azure-iotcentral-client/node_modules/react-native-paho-mqtt/src/ConnectMessage.js"],"names":["options","first","MESSAGE_TYPE","CONNECT","remLength","willMessagePayloadBytes","mqttVersion","MqttProtoIdentifierv3","length","MqttProtoIdentifierv4","clientId","willMessage","payloadBytes","destinationName","Uint8Array","byteLength","userName","password","mbi","pos","buffer","ArrayBuffer","byteStream","set","connectFlags","cleanSession","qos","retained","keepAliveInterval"],"mappings":"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","sourcesContent":["/* @flow */\n\nimport { encodeMultiByteInteger, lengthOfUTF8, writeString, writeUint16 } from './util';\nimport { MESSAGE_TYPE, MqttProtoIdentifierv3, MqttProtoIdentifierv4 } from './constants';\nimport Message from './Message';\n\ntype ConnectOptions = {\n  cleanSession: boolean;\n  userName: ?string;\n  password: ?string;\n  mqttVersion: 3 | 4;\n  willMessage: ?Message;\n  keepAliveInterval: number;\n  clientId: string;\n}\n\nexport default class {\n  options: ConnectOptions;\n\n  constructor(options: ConnectOptions) {\n    this.options = options;\n  }\n\n  encode(): ArrayBuffer {\n    const options = this.options;\n\n    // Compute the first byte of the fixed header\n    const first = ((MESSAGE_TYPE.CONNECT & 0x0f) << 4);\n\n    /*\n     * Now calculate the length of the variable header + payload by adding up the lengths\n     * of all the component parts\n     */\n\n    let remLength = 0;\n    let willMessagePayloadBytes;\n\n\n    switch (options.mqttVersion) {\n      case 3:\n        remLength += MqttProtoIdentifierv3.length + 3;\n        break;\n      case 4:\n        remLength += MqttProtoIdentifierv4.length + 3;\n        break;\n    }\n\n    remLength += lengthOfUTF8(options.clientId) + 2;\n    if (options.willMessage) {\n      willMessagePayloadBytes = options.willMessage.payloadBytes;\n      // Will message is always a string, sent as UTF-8 characters with a preceding length.\n      remLength += lengthOfUTF8(options.willMessage.destinationName) + 2;\n      if (!(willMessagePayloadBytes instanceof Uint8Array)) {\n        willMessagePayloadBytes = new Uint8Array(willMessagePayloadBytes);\n      }\n      remLength += willMessagePayloadBytes.byteLength + 2;\n    }\n    if (options.userName) {\n      remLength += lengthOfUTF8(options.userName) + 2;\n      if (options.password) {\n        remLength += lengthOfUTF8(options.password) + 2;\n      }\n    }\n\n    // Now we can allocate a buffer for the message\n\n    const mbi = encodeMultiByteInteger(remLength);  // Convert the length to MQTT MBI format\n    let pos = mbi.length + 1;        // Offset of start of variable header\n    const buffer = new ArrayBuffer(remLength + pos);\n    const byteStream = new Uint8Array(buffer);    // view it as a sequence of bytes\n\n    //Write the fixed header into the buffer\n    byteStream[0] = first;\n    byteStream.set(mbi, 1);\n\n    switch (options.mqttVersion) {\n      case 3:\n        byteStream.set(MqttProtoIdentifierv3, pos);\n        pos += MqttProtoIdentifierv3.length;\n        break;\n      case 4:\n        byteStream.set(MqttProtoIdentifierv4, pos);\n        pos += MqttProtoIdentifierv4.length;\n        break;\n    }\n    let connectFlags = 0;\n    if (options.cleanSession) {\n      connectFlags = 0x02;\n    }\n    if (options.willMessage) {\n      connectFlags |= 0x04;\n      connectFlags |= (options.willMessage.qos << 3);\n      if (options.willMessage.retained) {\n        connectFlags |= 0x20;\n      }\n    }\n    if (options.userName) {\n      connectFlags |= 0x80;\n    }\n    if (options.password) {\n      connectFlags |= 0x40;\n    }\n    byteStream[pos++] = connectFlags;\n    pos = writeUint16(options.keepAliveInterval, byteStream, pos);\n\n    pos = writeString(options.clientId, lengthOfUTF8(options.clientId), byteStream, pos);\n    if (options.willMessage) {\n      willMessagePayloadBytes = options.willMessage.payloadBytes;\n      pos = writeString(options.willMessage.destinationName, lengthOfUTF8(options.willMessage.destinationName), byteStream, pos);\n      pos = writeUint16(willMessagePayloadBytes.byteLength, byteStream, pos);\n      byteStream.set(willMessagePayloadBytes, pos);\n      pos += willMessagePayloadBytes.byteLength;\n\n    }\n    if (options.userName) {\n      pos = writeString(options.userName, lengthOfUTF8(options.userName), byteStream, pos);\n      if (options.password) {\n        writeString(options.password, lengthOfUTF8(options.password), byteStream, pos);\n      }\n    }\n    return buffer;\n  }\n}\n"]},"metadata":{},"sourceType":"script"}
{"ast":null,"code":"\"use strict\";\n\nvar _defineProperty = require(\"@babel/runtime/helpers/defineProperty\");\n\nvar _extends = require(\"@babel/runtime/helpers/extends\");\n\nvar _regeneratorRuntime = require(\"@babel/runtime/regenerator\");\n\nvar _classCallCheck = require(\"@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"@babel/runtime/helpers/createClass\");\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar interfaces_1 = require(\"./types/interfaces\");\n\nvar constants_1 = require(\"./types/constants\");\n\nvar consoleLogger_1 = require(\"./consoleLogger\");\n\nvar provision_1 = __importDefault(require(\"./provision\"));\n\nvar react_native_paho_mqtt_1 = require(\"react-native-paho-mqtt\");\n\nrequire(\"react-native-get-random-values\");\n\nvar uuid_1 = require(\"uuid\");\n\nvar enc_base64_1 = require(\"crypto-js/enc-base64\");\n\nvar crypto_js_1 = __importDefault(require(\"crypto-js\"));\n\nvar utils_1 = require(\"./utils\");\n\nvar myStorage = {\n  setItem: function setItem(key, item) {\n    myStorage[key] = item;\n  },\n  getItem: function getItem(key) {\n    return myStorage[key];\n  },\n  removeItem: function removeItem(key) {\n    delete myStorage[key];\n  }\n};\nvar TOPIC_TWIN = \"$iothub/twin/res\";\nvar TOPIC_PROPERTIES = \"$iothub/twin/PATCH/properties/desired\";\nvar TOPIC_COMMANDS = \"$iothub/methods/POST\";\n\nvar TOPIC_C2D = function TOPIC_C2D(id) {\n  return \"devices/\" + id + \"/messages/devicebound\";\n};\n\nvar HTTPS_API_VERSION = \"2018-06-30\";\n\nvar IoTCClient = function () {\n  function IoTCClient(id, scopeId, authenticationType, options, logger) {\n    _classCallCheck(this, IoTCClient);\n\n    this.id = id;\n    this.scopeId = scopeId;\n    this.authenticationType = authenticationType;\n    this.options = options;\n    this.endpoint = constants_1.DPS_DEFAULT_ENDPOINT;\n    this.connected = false;\n\n    if (typeof authenticationType == \"string\") {\n      this.authenticationType = constants_1.IOTC_CONNECT[authenticationType.toUpperCase()];\n    }\n\n    if (logger) {\n      this.logger = logger;\n    } else {\n      this.logger = new consoleLogger_1.ConsoleLogger();\n    }\n\n    if (this.authenticationType !== constants_1.IOTC_CONNECT.CONN_STRING) {\n      this.deviceProvisioning = provision_1.default.createKeyClient(this.endpoint, id, scopeId, authenticationType, options);\n    }\n\n    this.events = {};\n    this.retry = 0;\n    this.receivedDisconnession = false;\n  }\n\n  _createClass(IoTCClient, [{\n    key: \"isConnected\",\n    value: function isConnected() {\n      return this.connected;\n    }\n  }, {\n    key: \"setGlobalEndpoint\",\n    value: function setGlobalEndpoint(endpoint) {\n      this.endpoint = endpoint;\n      this.logger.log(\"Endpoint set to \" + endpoint + \".\");\n    }\n  }, {\n    key: \"setModelId\",\n    value: function setModelId(modelId) {\n      this.modelId = modelId;\n    }\n  }, {\n    key: \"sendTelemetry\",\n    value: function sendTelemetry(payload, properties) {\n      var topic, msg;\n      return _regeneratorRuntime.async(function sendTelemetry$(_context) {\n        while (1) {\n          switch (_context.prev = _context.next) {\n            case 0:\n              if (!(!this.mqttClient || !this.isConnected())) {\n                _context.next = 2;\n                break;\n              }\n\n              throw new Error(\"Device not connected\");\n\n            case 2:\n              topic = \"devices/\" + this.id + \"/messages/events/\";\n\n              if (properties) {\n                Object.keys(properties).forEach(function (prop, index) {\n                  topic = \"\" + topic + encodeURIComponent(prop) + \"=\" + encodeURIComponent(properties[prop]);\n\n                  if (index < properties.length - 1) {\n                    topic = topic + \"&\";\n                  }\n                });\n              }\n\n              msg = new react_native_paho_mqtt_1.Message(JSON.stringify(payload));\n              msg.destinationName = topic;\n              return _context.abrupt(\"return\", this.mqttClient.send(msg));\n\n            case 7:\n            case \"end\":\n              return _context.stop();\n          }\n        }\n      }, null, this, null, Promise);\n    }\n  }, {\n    key: \"sendProperty\",\n    value: function sendProperty(property) {\n      var msg;\n      return _regeneratorRuntime.async(function sendProperty$(_context2) {\n        while (1) {\n          switch (_context2.prev = _context2.next) {\n            case 0:\n              if (!(!this.mqttClient || !this.isConnected())) {\n                _context2.next = 2;\n                break;\n              }\n\n              throw new Error(\"Device not connected\");\n\n            case 2:\n              msg = new react_native_paho_mqtt_1.Message(JSON.stringify(property));\n              msg.destinationName = \"$iothub/twin/PATCH/properties/reported/?$rid=\" + uuid_1.v4();\n              return _context2.abrupt(\"return\", this.mqttClient.send(msg));\n\n            case 5:\n            case \"end\":\n              return _context2.stop();\n          }\n        }\n      }, null, this, null, Promise);\n    }\n  }, {\n    key: \"disconnect\",\n    value: function disconnect() {\n      var _a;\n\n      return _regeneratorRuntime.async(function disconnect$(_context3) {\n        while (1) {\n          switch (_context3.prev = _context3.next) {\n            case 0:\n              this.receivedDisconnession = true;\n              _context3.next = 3;\n              return _regeneratorRuntime.awrap(this.logger.log(\"Disconnecting client...\"));\n\n            case 3:\n              _context3.next = 5;\n              return _regeneratorRuntime.awrap((_a = this.mqttClient) === null || _a === void 0 ? void 0 : _a.disconnect());\n\n            case 5:\n              delete this.mqttClient;\n              this.mqttClient = undefined;\n              this.connected = false;\n\n            case 8:\n            case \"end\":\n              return _context3.stop();\n          }\n        }\n      }, null, this, null, Promise);\n    }\n  }, {\n    key: \"connect\",\n    value: function connect(opts) {\n      var _this = this;\n\n      var _a, _b, _c, _d, _e, _f, _g, config;\n\n      return _regeneratorRuntime.async(function connect$(_context5) {\n        while (1) {\n          switch (_context5.prev = _context5.next) {\n            case 0:\n              config = _extends({\n                cleanSession: false,\n                timeout: 30\n              }, opts);\n              _context5.next = 3;\n              return _regeneratorRuntime.awrap(this.logger.log(\"Connecting client \" + this.id + \" ...\"));\n\n            case 3:\n              (_a = config.cancellationToken) === null || _a === void 0 ? void 0 : _a.throwIfCancelled(\"Start connection\");\n              _context5.next = 6;\n              return _regeneratorRuntime.awrap(utils_1.promiseTimeout(this.deviceProvisioning ? this.deviceProvisioning.register.bind(this.deviceProvisioning, this.modelId) : function () {\n                return Promise.resolve(_this.options);\n              }, config.timeout * 1000));\n\n            case 6:\n              this.credentials = _context5.sent;\n              (_b = config.cancellationToken) === null || _b === void 0 ? void 0 : _b.throwIfCancelled(\"Provisioning\");\n              _context5.next = 10;\n              return _regeneratorRuntime.awrap(this.logger.debug(\"Got credentials from DPS\\n\" + JSON.stringify(this.credentials)));\n\n            case 10:\n              this.mqttClient = new react_native_paho_mqtt_1.Client({\n                uri: \"wss://\" + this.credentials.host + \":443/$iothub/websocket\",\n                clientId: this.id,\n                storage: myStorage,\n                webSocket: WebSocket\n              });\n              (_c = config.cancellationToken) === null || _c === void 0 ? void 0 : _c.throwIfCancelled(\"Hub client init\");\n              this.mqttClient.on(\"connectionLost\", function _callee(responseObject) {\n                return _regeneratorRuntime.async(function _callee$(_context4) {\n                  while (1) {\n                    switch (_context4.prev = _context4.next) {\n                      case 0:\n                        if (!_this.receivedDisconnession) {\n                          _context4.next = 2;\n                          break;\n                        }\n\n                        return _context4.abrupt(\"return\");\n\n                      case 2:\n                        _this.connected = false;\n\n                        if (!(responseObject.errorCode !== 0)) {\n                          _context4.next = 6;\n                          break;\n                        }\n\n                        _context4.next = 6;\n                        return _regeneratorRuntime.awrap(_this.logger.debug(responseObject.errorMessage));\n\n                      case 6:\n                        _this.retry = 0;\n                        _context4.next = 9;\n                        return _regeneratorRuntime.awrap(utils_1.promiseTimeout(_this.clientConnect.bind(_this, config), config.timeout * 1000));\n\n                      case 9:\n                        _context4.next = 11;\n                        return _regeneratorRuntime.awrap(_this.subscribe());\n\n                      case 11:\n                      case \"end\":\n                        return _context4.stop();\n                    }\n                  }\n                }, null, null, null, Promise);\n              });\n              this.mqttClient.on(\"messageReceived\", this.onMessageReceived.bind(this));\n              (_d = config.cancellationToken) === null || _d === void 0 ? void 0 : _d.throwIfCancelled(\"Connection callbacks applied\");\n              _context5.next = 17;\n              return _regeneratorRuntime.awrap(utils_1.promiseTimeout(this.clientConnect.bind(this, config), config.timeout * 1000));\n\n            case 17:\n              (_e = config.cancellationToken) === null || _e === void 0 ? void 0 : _e.throwIfCancelled(\"Hub connection completed\");\n              _context5.next = 20;\n              return _regeneratorRuntime.awrap(this.subscribe());\n\n            case 20:\n              (_f = config.cancellationToken) === null || _f === void 0 ? void 0 : _f.throwIfCancelled(\"Hub topic subscriptions\");\n              _context5.next = 23;\n              return _regeneratorRuntime.awrap(this.fetchTwin());\n\n            case 23:\n              (_g = config.cancellationToken) === null || _g === void 0 ? void 0 : _g.throwIfCancelled(\"Fetch Twin\");\n\n            case 24:\n            case \"end\":\n              return _context5.stop();\n          }\n        }\n      }, null, this, null, Promise);\n    }\n  }, {\n    key: \"fetchTwin\",\n    value: function fetchTwin() {\n      var twinMsg;\n      return _regeneratorRuntime.async(function fetchTwin$(_context6) {\n        while (1) {\n          switch (_context6.prev = _context6.next) {\n            case 0:\n              if (!(this.mqttClient && this.connected)) {\n                _context6.next = 5;\n                break;\n              }\n\n              twinMsg = new react_native_paho_mqtt_1.Message(\"\");\n              twinMsg.destinationName = \"$iothub/twin/GET/?$rid=\" + uuid_1.v4();\n              _context6.next = 5;\n              return _regeneratorRuntime.awrap(this.mqttClient.send(twinMsg));\n\n            case 5:\n            case \"end\":\n              return _context6.stop();\n          }\n        }\n      }, null, this, null, Promise);\n    }\n  }, {\n    key: \"onMessageReceived\",\n    value: function onMessageReceived(message) {\n      var match, cmd, regex, _match, data, _cmd;\n\n      return _regeneratorRuntime.async(function onMessageReceived$(_context7) {\n        while (1) {\n          switch (_context7.prev = _context7.next) {\n            case 0:\n              if (!message.destinationName.startsWith(TOPIC_TWIN + \"/200\")) {\n                _context7.next = 6;\n                break;\n              }\n\n              _context7.next = 3;\n              return _regeneratorRuntime.awrap(this.logger.debug(\"Received twin message: \" + message.payloadString));\n\n            case 3:\n              try {\n                this.twin = JSON.parse(message.payloadString);\n\n                if (this.twin.desired) {\n                  this.onPropertiesUpdated(this.twin.desired);\n                }\n              } catch (e) {\n                this.twin = null;\n              }\n\n              _context7.next = 13;\n              break;\n\n            case 6:\n              if (!message.destinationName.startsWith(TOPIC_PROPERTIES)) {\n                _context7.next = 12;\n                break;\n              }\n\n              _context7.next = 9;\n              return _regeneratorRuntime.awrap(this.logger.log(\"Received desired property message: \" + message.payloadString));\n\n            case 9:\n              this.onPropertiesUpdated(JSON.parse(message.payloadString));\n              _context7.next = 13;\n              break;\n\n            case 12:\n              if (message.destinationName.startsWith(TOPIC_COMMANDS)) {\n                match = message.destinationName.match(/\\$iothub\\/methods\\/POST\\/(.+)\\/\\?\\$rid=(.+)/);\n\n                if (match && match.length === 3) {\n                  this.logger.log(\"Received command \" + match[1] + \".\");\n                  cmd = {\n                    name: match[1],\n                    requestId: match[2]\n                  };\n\n                  if (message.payloadString) {\n                    this.logger.debug(\"Command \" + match[1] + \" received with payload '\" + message.payloadString + \"'\");\n                    cmd[\"requestPayload\"] = message.payloadString;\n                  }\n\n                  this.onCommandReceived(cmd);\n                }\n              } else if (message.destinationName.startsWith(TOPIC_C2D(this.id))) {\n                regex = new RegExp(\"devices/\" + this.id + \"/messages/devicebound/([\\\\S]+)\", \"g\");\n                _match = regex.exec(message.destinationName);\n\n                if (_match && _match.length === 2) {\n                  data = decodeURIComponent(_match[1]).split(\"&\").reduce(function (obj, item) {\n                    var kv = item.split(\"=\");\n                    return obj = _extends(_extends({}, obj), _defineProperty({}, kv[0], kv[1]));\n                  }, {});\n                  _cmd = {\n                    name: data[\"method-name\"].split(\":\")[1]\n                  };\n\n                  if (message.payloadString) {\n                    _cmd[\"requestPayload\"] = message.payloadString;\n                  }\n\n                  this.onCommandReceived(_cmd);\n                }\n              }\n\n            case 13:\n            case \"end\":\n              return _context7.stop();\n          }\n        }\n      }, null, this, null, Promise);\n    }\n  }, {\n    key: \"on\",\n    value: function on(eventName, callback) {\n      if (typeof eventName == \"number\") {\n        eventName = constants_1.IOTC_EVENTS[eventName];\n      }\n\n      var properties = eventName.match(/^Properties$|Properties\\.([\\S]+)/);\n      var commands = eventName.match(/^Commands$|Commands\\.([\\S]+)/);\n\n      if (properties) {\n        this.events[constants_1.IOTC_EVENTS.Properties] = {\n          callback: callback,\n          filter: properties[1] ? properties[1] : undefined\n        };\n      } else if (commands) {\n        this.events[constants_1.IOTC_EVENTS.Commands] = {\n          callback: callback,\n          filter: commands[1] ? commands[1] : undefined\n        };\n      }\n    }\n  }, {\n    key: \"clientConnect\",\n    value: function clientConnect(config) {\n      var cleanSession, timeout;\n      return _regeneratorRuntime.async(function clientConnect$(_context8) {\n        while (1) {\n          switch (_context8.prev = _context8.next) {\n            case 0:\n              cleanSession = config.cleanSession, timeout = config.timeout;\n\n              if (!(this.retry == 5)) {\n                _context8.next = 3;\n                break;\n              }\n\n              throw new Error(\"No connection after multiple retries\");\n\n            case 3:\n              if (!(!this.mqttClient || this.connected || !this.credentials)) {\n                _context8.next = 5;\n                break;\n              }\n\n              return _context8.abrupt(\"return\");\n\n            case 5:\n              _context8.prev = 5;\n              _context8.next = 8;\n              return _regeneratorRuntime.awrap(this.mqttClient.connect({\n                userName: this.credentials.host + \"/\" + this.id + \"/?api-version=\" + constants_1.IOTHUB_API_VERSION + (this.modelId ? \"&model-id=\" + this.modelId : \"\"),\n                password: this.credentials.password,\n                delay: 5,\n                cleanSession: cleanSession,\n                timeout: timeout * 1000\n              }));\n\n            case 8:\n              _context8.next = 17;\n              break;\n\n            case 10:\n              _context8.prev = 10;\n              _context8.t0 = _context8[\"catch\"](5);\n              this.retry++;\n              _context8.next = 15;\n              return _regeneratorRuntime.awrap(new Promise(function (r) {\n                return setTimeout(r, 2000);\n              }));\n\n            case 15:\n              _context8.next = 17;\n              return _regeneratorRuntime.awrap(this.clientConnect(config));\n\n            case 17:\n              this.connected = true;\n              _context8.next = 20;\n              return _regeneratorRuntime.awrap(this.logger.log(\"Device connected\"));\n\n            case 20:\n            case \"end\":\n              return _context8.stop();\n          }\n        }\n      }, null, this, [[5, 10]], Promise);\n    }\n  }, {\n    key: \"subscribe\",\n    value: function subscribe() {\n      return _regeneratorRuntime.async(function subscribe$(_context9) {\n        while (1) {\n          switch (_context9.prev = _context9.next) {\n            case 0:\n              if (!(!this.mqttClient || !this.connected)) {\n                _context9.next = 2;\n                break;\n              }\n\n              return _context9.abrupt(\"return\");\n\n            case 2:\n              if (!this.id) {\n                _context9.next = 5;\n                break;\n              }\n\n              _context9.next = 5;\n              return _regeneratorRuntime.awrap(this.mqttClient.subscribe(TOPIC_C2D(this.id) + \"/#\"));\n\n            case 5:\n              _context9.next = 7;\n              return _regeneratorRuntime.awrap(this.mqttClient.subscribe(TOPIC_TWIN + \"/#\"));\n\n            case 7:\n              _context9.next = 9;\n              return _regeneratorRuntime.awrap(this.mqttClient.subscribe(TOPIC_PROPERTIES + \"/#\"));\n\n            case 9:\n              _context9.next = 11;\n              return _regeneratorRuntime.awrap(this.mqttClient.subscribe(TOPIC_COMMANDS + \"/#\"));\n\n            case 11:\n            case \"end\":\n              return _context9.stop();\n          }\n        }\n      }, null, this, null, Promise);\n    }\n  }, {\n    key: \"onPropertiesUpdated\",\n    value: function onPropertiesUpdated(properties) {\n      var _this2 = this;\n\n      var listener = this.events[constants_1.IOTC_EVENTS.Properties];\n\n      if (!listener) {\n        return;\n      }\n\n      Object.keys(properties).forEach(function (prop) {\n        if (listener.filter && listener.filter != prop || prop === \"$version\") {\n          return;\n        }\n\n        var propVersion = properties[\"$version\"];\n        var value = properties[prop];\n        var valueType = typeof properties[prop];\n\n        if (valueType === \"object\" && value.value) {\n          value = value.value;\n        }\n\n        listener.callback({\n          name: prop,\n          value: value,\n          version: propVersion,\n          ack: function _callee2(message) {\n            return _regeneratorRuntime.async(function _callee2$(_context10) {\n              while (1) {\n                switch (_context10.prev = _context10.next) {\n                  case 0:\n                    _context10.next = 2;\n                    return _regeneratorRuntime.awrap(this.sendProperty(_defineProperty({}, prop, {\n                      ac: 200,\n                      ad: message ? message : \"Property applied\",\n                      av: propVersion,\n                      value: value\n                    })));\n\n                  case 2:\n                  case \"end\":\n                    return _context10.stop();\n                }\n              }\n            }, null, this, null, Promise);\n          }.bind(_this2)\n        });\n      });\n    }\n  }, {\n    key: \"onCommandReceived\",\n    value: function onCommandReceived(command) {\n      var listener = this.events[constants_1.IOTC_EVENTS.Commands];\n\n      if (!listener) {\n        return;\n      }\n\n      if (listener.filter && listener.filter != command.name) {\n        return;\n      }\n\n      listener.callback({\n        name: command.name,\n        requestPayload: command.requestPayload,\n        requestId: command.requestId,\n        reply: function _callee3(status, message) {\n          return _regeneratorRuntime.async(function _callee3$(_context11) {\n            while (1) {\n              switch (_context11.prev = _context11.next) {\n                case 0:\n                  _context11.next = 2;\n                  return _regeneratorRuntime.awrap(this.ackCommand(message, command.requestId, status));\n\n                case 2:\n                case \"end\":\n                  return _context11.stop();\n              }\n            }\n          }, null, this, null, Promise);\n        }.bind(this)\n      });\n    }\n  }, {\n    key: \"ackCommand\",\n    value: function ackCommand(message, requestId, status) {\n      var msg, responseStatus;\n      return _regeneratorRuntime.async(function ackCommand$(_context12) {\n        while (1) {\n          switch (_context12.prev = _context12.next) {\n            case 0:\n              if (!(!this.mqttClient || !this.connected)) {\n                _context12.next = 2;\n                break;\n              }\n\n              return _context12.abrupt(\"return\");\n\n            case 2:\n              if (!requestId) {\n                _context12.next = 11;\n                break;\n              }\n\n              msg = new react_native_paho_mqtt_1.Message(message);\n              responseStatus = 200;\n\n              if (status && status == interfaces_1.IIoTCCommandResponse.ERROR) {\n                responseStatus = 500;\n              }\n\n              msg.destinationName = \"$iothub/methods/res/\" + responseStatus + \"/?$rid=\" + requestId;\n              _context12.next = 9;\n              return _regeneratorRuntime.awrap(this.mqttClient.send(msg));\n\n            case 9:\n              _context12.next = 12;\n              break;\n\n            case 11:\n              return _context12.abrupt(\"return\");\n\n            case 12:\n            case \"end\":\n              return _context12.stop();\n          }\n        }\n      }, null, this, null, Promise);\n    }\n  }, {\n    key: \"setLogging\",\n    value: function setLogging(logLevel) {\n      this.logger.setLogLevel(logLevel);\n      this.logger.log(\"Log level set to \" + logLevel);\n    }\n  }, {\n    key: \"uploadFile\",\n    value: function uploadFile(fileName, contentType, fileData, encoding) {\n      var filereq, res, uploadRes, notif;\n      return _regeneratorRuntime.async(function uploadFile$(_context13) {\n        while (1) {\n          switch (_context13.prev = _context13.next) {\n            case 0:\n              if (!(!this.mqttClient || !this.connected || !this.credentials)) {\n                _context13.next = 2;\n                break;\n              }\n\n              return _context13.abrupt(\"return\", {\n                status: -1,\n                errorMessage: \"Client is not connected!\"\n              });\n\n            case 2:\n              _context13.next = 4;\n              return _regeneratorRuntime.awrap(fetch(\"https://\" + this.credentials.host + \"/devices/\" + this.id + \"/files?api-version=\" + HTTPS_API_VERSION, {\n                method: \"POST\",\n                body: JSON.stringify({\n                  blobName: fileName\n                }),\n                headers: {\n                  Authorization: this.credentials.password,\n                  \"Content-Type\": \"application/json\"\n                }\n              }));\n\n            case 4:\n              res = _context13.sent;\n\n              if (!(res && res.status >= 200 && res.status < 300)) {\n                _context13.next = 27;\n                break;\n              }\n\n              _context13.next = 8;\n              return _regeneratorRuntime.awrap(res.json());\n\n            case 8:\n              filereq = _context13.sent;\n\n              if (encoding && encoding === \"base64\") {\n                fileData = utils_1.CryptJsWordArrayToUint8Array(enc_base64_1.parse.bind(crypto_js_1.default.enc.Base64)(fileData));\n              }\n\n              _context13.next = 12;\n              return _regeneratorRuntime.awrap(fetch(\"https://\" + filereq.hostName + \"/\" + filereq.containerName + \"/\" + filereq.blobName + filereq.sasToken, {\n                method: \"PUT\",\n                headers: {\n                  \"x-ms-version\": \"2015-02-21\",\n                  \"x-ms-date\": new Date().toUTCString(),\n                  \"Content-Type\": contentType,\n                  \"Content-Length\": \"\" + fileData.length,\n                  \"x-ms-blob-content-disposition\": \"attachment; filename=\\\"\" + fileName + \"\\\"\",\n                  \"x-ms-blob-type\": \"BlockBlob\"\n                },\n                body: fileData.buffer\n              }));\n\n            case 12:\n              uploadRes = _context13.sent;\n\n              if (!uploadRes) {\n                _context13.next = 27;\n                break;\n              }\n\n              notif = {\n                correlationId: filereq.correlationId,\n                isSuccess: uploadRes.status >= 200 && uploadRes.status < 300,\n                statusCode: uploadRes.status,\n                statusDescription: uploadRes.statusText\n              };\n              _context13.next = 17;\n              return _regeneratorRuntime.awrap(fetch(\"https://\" + this.credentials.host + \"/devices/\" + this.id + \"/files/notifications?api-version=\" + HTTPS_API_VERSION, {\n                method: \"POST\",\n                body: JSON.stringify(notif),\n                headers: {\n                  Authorization: this.credentials.password,\n                  \"Content-Type\": \"application/json\"\n                }\n              }));\n\n            case 17:\n              _context13.t0 = uploadRes.status;\n\n              if (!(uploadRes.status >= 200 && uploadRes.status < 300)) {\n                _context13.next = 22;\n                break;\n              }\n\n              _context13.t1 = undefined;\n              _context13.next = 25;\n              break;\n\n            case 22:\n              _context13.next = 24;\n              return _regeneratorRuntime.awrap(uploadRes.text());\n\n            case 24:\n              _context13.t1 = _context13.sent;\n\n            case 25:\n              _context13.t2 = _context13.t1;\n              return _context13.abrupt(\"return\", {\n                status: _context13.t0,\n                errorMessage: _context13.t2\n              });\n\n            case 27:\n              _context13.t3 = res.status;\n              _context13.next = 30;\n              return _regeneratorRuntime.awrap(res.text());\n\n            case 30:\n              _context13.t4 = _context13.sent;\n              return _context13.abrupt(\"return\", {\n                status: _context13.t3,\n                errorMessage: _context13.t4\n              });\n\n            case 32:\n            case \"end\":\n              return _context13.stop();\n          }\n        }\n      }, null, this, null, Promise);\n    }\n  }], [{\n    key: \"getFromConnectionString\",\n    value: function getFromConnectionString(connectionString, logger) {\n      var creds = utils_1.parseConnectionString(connectionString);\n      return new IoTCClient(creds.deviceId, \"\", constants_1.IOTC_CONNECT.CONN_STRING, creds, logger);\n    }\n  }]);\n\n  return IoTCClient;\n}();\n\nexports.default = IoTCClient;","map":{"version":3,"sources":["../src/client.ts"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;AAGA,IAAA,YAAA,GAAA,OAAA,CAAA,oBAAA,CAAA;;AAaA,IAAA,WAAA,GAAA,OAAA,CAAA,mBAAA,CAAA;;AAOA,IAAA,eAAA,GAAA,OAAA,CAAA,iBAAA,CAAA;;AACA,IAAA,WAAA,GAAA,eAAA,CAAA,OAAA,CAAA,aAAA,CAAA,CAAA;;AACA,IAAA,wBAAA,GAAA,OAAA,CAAA,wBAAA,CAAA;;AACA,OAAA,CAAA,gCAAA,CAAA;;AACA,IAAA,MAAA,GAAA,OAAA,CAAA,MAAA,CAAA;;AACA,IAAA,YAAA,GAAA,OAAA,CAAA,sBAAA,CAAA;;AACA,IAAA,WAAA,GAAA,eAAA,CAAA,OAAA,CAAA,WAAA,CAAA,CAAA;;AACA,IAAA,OAAA,GAAA,OAAA,CAAA,SAAA,CAAA;;AAOA,IAAM,SAAS,GAAQ;AACrB,EAAA,OAAO,EAAE,iBAAC,GAAD,EAAc,IAAd,EAA8B;AACrC,IAAA,SAAS,CAAC,GAAD,CAAT,GAAiB,IAAjB;AACD,GAHoB;AAIrB,EAAA,OAAO,EAAE,iBAAC,GAAD;AAAA,WAAiB,SAAS,CAAC,GAAD,CAA1B;AAAA,GAJY;AAKrB,EAAA,UAAU,EAAE,oBAAC,GAAD,EAAgB;AAC1B,WAAO,SAAS,CAAC,GAAD,CAAhB;AACD;AAPoB,CAAvB;AAUA,IAAM,UAAU,GAAG,kBAAnB;AACA,IAAM,gBAAgB,GAAG,uCAAzB;AACA,IAAM,cAAc,GAAG,sBAAvB;;AACA,IAAM,SAAS,GAAG,SAAZ,SAAY,CAAC,EAAD;AAAA,sBAA2B,EAA3B;AAAA,CAAlB;;AACA,IAAM,iBAAiB,GAAG,YAA1B;;IAEqB,U;AAqCnB,sBACW,EADX,EAEW,OAFX,EAGW,kBAHX,EAIW,OAJX,EAKE,MALF,EAKsB;AAAA;;AAJX,SAAA,EAAA,GAAA,EAAA;AACA,SAAA,OAAA,GAAA,OAAA;AACA,SAAA,kBAAA,GAAA,kBAAA;AACA,SAAA,OAAA,GAAA,OAAA;AA9BH,SAAA,QAAA,GAAmB,WAAA,CAAA,oBAAnB;AAGA,SAAA,SAAA,GAAqB,KAArB;;AA8BN,QAAI,OAAO,kBAAP,IAA6B,QAAjC,EAA2C;AACzC,WAAK,kBAAL,GACE,WAAA,CAAA,YAAA,CACE,kBAAkB,CAAC,WAAnB,EADF,CADF;AAID;;AACD,QAAI,MAAJ,EAAY;AACV,WAAK,MAAL,GAAc,MAAd;AACD,KAFD,MAEO;AACL,WAAK,MAAL,GAAc,IAAI,eAAA,CAAA,aAAJ,EAAd;AACD;;AACD,QAAI,KAAK,kBAAL,KAA4B,WAAA,CAAA,YAAA,CAAa,WAA7C,EAA0D;AACxD,WAAK,kBAAL,GAA0B,WAAA,CAAA,OAAA,CAAmB,eAAnB,CACxB,KAAK,QADmB,EAExB,EAFwB,EAGxB,OAHwB,EAIxB,kBAJwB,EAKxB,OALwB,CAA1B;AAOD;;AACD,SAAK,MAAL,GAAc,EAAd;AACA,SAAK,KAAL,GAAa,CAAb;AACA,SAAK,qBAAL,GAA6B,KAA7B;AACD;;;;WAlED,uBAAW;AACT,aAAO,KAAK,SAAZ;AACD;;;WAkED,2BAAkB,QAAlB,EAAkC;AAChC,WAAK,QAAL,GAAgB,QAAhB;AACA,WAAK,MAAL,CAAY,GAAZ,sBAAmC,QAAnC;AACD;;;WAED,oBAAW,OAAX,EAA0B;AACxB,WAAK,OAAL,GAAe,OAAf;AACD;;;WAED,uBAAoB,OAApB,EAAkC,UAAlC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,oBACM,CAAC,KAAK,UAAN,IAAoB,CAAC,KAAK,WAAL,EAD3B;AAAA;AAAA;AAAA;;AAAA,oBAEU,IAAI,KAAJ,CAAU,sBAAV,CAFV;;AAAA;AAIM,cAAA,KAJN,gBAIyB,KAAK,EAJ9B;;AAKE,kBAAI,UAAJ,EAAgB;AACd,gBAAA,MAAM,CAAC,IAAP,CAAY,UAAZ,EAAwB,OAAxB,CAAgC,UAAC,IAAD,EAAO,KAAP,EAAgB;AAC9C,kBAAA,KAAK,QAAM,KAAN,GAAc,kBAAkB,CAAC,IAAD,CAAhC,SAA0C,kBAAkB,CAC/D,UAAU,CAAC,IAAD,CADqD,CAAjE;;AAGA,sBAAI,KAAK,GAAG,UAAU,CAAC,MAAX,GAAoB,CAAhC,EAAmC;AACjC,oBAAA,KAAK,GAAM,KAAN,MAAL;AACD;AACF,iBAPD;AAQD;;AACG,cAAA,GAfN,GAeY,IAAI,wBAAA,CAAA,OAAJ,CAAY,IAAI,CAAC,SAAL,CAAe,OAAf,CAAZ,CAfZ;AAgBE,cAAA,GAAG,CAAC,eAAJ,GAAsB,KAAtB;AAhBF,+CAiBS,KAAK,UAAL,CAAgB,IAAhB,CAAqB,GAArB,CAjBT;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;WAoBA,sBAAmB,QAAnB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,oBACM,CAAC,KAAK,UAAN,IAAoB,CAAC,KAAK,WAAL,EAD3B;AAAA;AAAA;AAAA;;AAAA,oBAEU,IAAI,KAAJ,CAAU,sBAAV,CAFV;;AAAA;AAIM,cAAA,GAJN,GAIY,IAAI,wBAAA,CAAA,OAAJ,CAAY,IAAI,CAAC,SAAL,CAAe,QAAf,CAAZ,CAJZ;AAKE,cAAA,GAAG,CAAC,eAAJ,qDAAsE,MAAA,CAAA,EAAA,EAAtE;AALF,gDAMS,KAAK,UAAL,CAAgB,IAAhB,CAAqB,GAArB,CANT;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;WASA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAEE,mBAAK,qBAAL,GAA6B,IAA7B;AAFF;AAAA,+CAIQ,KAAK,MAAL,CAAY,GAAZ,2BAJR;;AAAA;AAAA;AAAA,+CAKE,CAAA,EAAA,GAAM,KAAK,UAAX,MAAqB,IAArB,IAAqB,EAAA,KAAA,KAAA,CAArB,GAAqB,KAAA,CAArB,GAAqB,EAAA,CAAE,UAAF,EALvB;;AAAA;AAME,qBAAO,KAAK,UAAZ;AACA,mBAAK,UAAL,GAAkB,SAAlB;AACA,mBAAK,SAAL,GAAiB,KAAjB;;AARF;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;WAWA,iBAAc,IAAd;AAAA;;AAAA;;AAAA;AAAA;AAAA;AAAA;AAKQ,cAAA,MALR,GAKc,SAAQ;AAAE,gBAAA,YAAY,EAAE,KAAhB;AAAuB,gBAAA,OAAO,EAAE;AAAhC,eAAR,EAAiD,IAAjD,CALd;AAAA;AAAA,+CAMQ,KAAK,MAAL,CAAY,GAAZ,wBAAqC,KAAK,EAA1C,UANR;;AAAA;AAOE,eAAA,EAAA,GAAA,MAAM,CAAC,iBAAP,MAAwB,IAAxB,IAAwB,EAAA,KAAA,KAAA,CAAxB,GAAwB,KAAA,CAAxB,GAAwB,EAAA,CAAE,gBAAF,CAAmB,kBAAnB,CAAxB;AAPF;AAAA,+CAS2B,OAAA,CAAA,cAAA,CACvB,KAAK,kBAAL,GAEI,KAAK,kBAAL,CAAwB,QAAxB,CAAiC,IAAjC,CACE,KAAK,kBADP,EAEE,KAAK,OAFP,CAFJ,GAOI;AAAA,uBAAM,OAAO,CAAC,OAAR,CAAgB,KAAI,CAAC,OAArB,CAAN;AAAA,eARmB,EASvB,MAAM,CAAC,OAAP,GAAiB,IATM,CAT3B;;AAAA;AASE,mBAAK,WATP;AAoBE,eAAA,EAAA,GAAA,MAAM,CAAC,iBAAP,MAAwB,IAAxB,IAAwB,EAAA,KAAA,KAAA,CAAxB,GAAwB,KAAA,CAAxB,GAAwB,EAAA,CAAE,gBAAF,CAAmB,cAAnB,CAAxB;AApBF;AAAA,+CAsBQ,KAAK,MAAL,CAAY,KAAZ,gCACyB,IAAI,CAAC,SAAL,CAAe,KAAK,WAApB,CADzB,CAtBR;;AAAA;AAyBE,mBAAK,UAAL,GAAkB,IAAI,wBAAA,CAAA,MAAJ,CAAe;AAC/B,gBAAA,GAAG,aAAW,KAAK,WAAL,CAAiB,IAA5B,2BAD4B;AAE/B,gBAAA,QAAQ,EAAE,KAAK,EAFgB;AAG/B,gBAAA,OAAO,EAAE,SAHsB;AAI/B,gBAAA,SAAS,EAAE;AAJoB,eAAf,CAAlB;AAMA,eAAA,EAAA,GAAA,MAAM,CAAC,iBAAP,MAAwB,IAAxB,IAAwB,EAAA,KAAA,KAAA,CAAxB,GAAwB,KAAA,CAAxB,GAAwB,EAAA,CAAE,gBAAF,CAAmB,iBAAnB,CAAxB;AACA,mBAAK,UAAL,CAAgB,EAAhB,CAAmB,gBAAnB,EAAqC,iBAAO,cAAP;AAAA;AAAA;AAAA;AAAA;AAAA,6BAC/B,KAAI,CAAC,qBAD0B;AAAA;AAAA;AAAA;;AAAA;;AAAA;AAKnC,wBAAA,KAAI,CAAC,SAAL,GAAiB,KAAjB;;AALmC,8BAM/B,cAAc,CAAC,SAAf,KAA6B,CANE;AAAA;AAAA;AAAA;;AAAA;AAAA,yDAO3B,KAAI,CAAC,MAAL,CAAY,KAAZ,CAAkB,cAAc,CAAC,YAAjC,CAP2B;;AAAA;AAUnC,wBAAA,KAAI,CAAC,KAAL,GAAa,CAAb;AAVmC;AAAA,yDAY7B,OAAA,CAAA,cAAA,CACJ,KAAI,CAAC,aAAL,CAAmB,IAAnB,CAAwB,KAAxB,EAA8B,MAA9B,CADI,EAEJ,MAAM,CAAC,OAAP,GAAiB,IAFb,CAZ6B;;AAAA;AAAA;AAAA,yDAgB7B,KAAI,CAAC,SAAL,EAhB6B;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,eAArC;AAmBA,mBAAK,UAAL,CAAgB,EAAhB,CAAmB,iBAAnB,EAAsC,KAAK,iBAAL,CAAuB,IAAvB,CAA4B,IAA5B,CAAtC;AACA,eAAA,EAAA,GAAA,MAAM,CAAC,iBAAP,MAAwB,IAAxB,IAAwB,EAAA,KAAA,KAAA,CAAxB,GAAwB,KAAA,CAAxB,GAAwB,EAAA,CAAE,gBAAF,CAAmB,8BAAnB,CAAxB;AApDF;AAAA,+CAqDQ,OAAA,CAAA,cAAA,CACJ,KAAK,aAAL,CAAmB,IAAnB,CAAwB,IAAxB,EAA8B,MAA9B,CADI,EAEJ,MAAM,CAAC,OAAP,GAAiB,IAFb,CArDR;;AAAA;AAyDE,eAAA,EAAA,GAAA,MAAM,CAAC,iBAAP,MAAwB,IAAxB,IAAwB,EAAA,KAAA,KAAA,CAAxB,GAAwB,KAAA,CAAxB,GAAwB,EAAA,CAAE,gBAAF,CAAmB,0BAAnB,CAAxB;AAzDF;AAAA,+CA0DQ,KAAK,SAAL,EA1DR;;AAAA;AA2DE,eAAA,EAAA,GAAA,MAAM,CAAC,iBAAP,MAAwB,IAAxB,IAAwB,EAAA,KAAA,KAAA,CAAxB,GAAwB,KAAA,CAAxB,GAAwB,EAAA,CAAE,gBAAF,CAAmB,yBAAnB,CAAxB;AA3DF;AAAA,+CA4DQ,KAAK,SAAL,EA5DR;;AAAA;AA6DE,eAAA,EAAA,GAAA,MAAM,CAAC,iBAAP,MAAwB,IAAxB,IAAwB,EAAA,KAAA,KAAA,CAAxB,GAAwB,KAAA,CAAxB,GAAwB,EAAA,CAAE,gBAAF,CAAmB,YAAnB,CAAxB;;AA7DF;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;WAgEO;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,oBACD,KAAK,UAAL,IAAmB,KAAK,SADvB;AAAA;AAAA;AAAA;;AAEC,cAAA,OAFD,GAEW,IAAI,wBAAA,CAAA,OAAJ,CAAY,EAAZ,CAFX;AAGH,cAAA,OAAO,CAAC,eAAR,+BAAoD,MAAA,CAAA,EAAA,EAApD;AAHG;AAAA,+CAIG,KAAK,UAAL,CAAgB,IAAhB,CAAqB,OAArB,CAJH;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;WAQC,2BAAwB,OAAxB;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA,mBACF,OAAO,CAAC,eAAR,CAAwB,UAAxB,CAAsC,UAAtC,UADE;AAAA;AAAA;AAAA;;AAAA;AAAA,+CAGE,KAAK,MAAL,CAAY,KAAZ,6BACsB,OAAO,CAAC,aAD9B,CAHF;;AAAA;AAMJ,kBAAI;AACF,qBAAK,IAAL,GAAY,IAAI,CAAC,KAAL,CAAW,OAAO,CAAC,aAAnB,CAAZ;;AACA,oBAAI,KAAK,IAAL,CAAU,OAAd,EAAuB;AACrB,uBAAK,mBAAL,CAAyB,KAAK,IAAL,CAAU,OAAnC;AACD;AACF,eALD,CAKE,OAAO,CAAP,EAAU;AACV,qBAAK,IAAL,GAAY,IAAZ;AACD;;AAbG;AAAA;;AAAA;AAAA,mBAcK,OAAO,CAAC,eAAR,CAAwB,UAAxB,CAAmC,gBAAnC,CAdL;AAAA;AAAA;AAAA;;AAAA;AAAA,+CAgBE,KAAK,MAAL,CAAY,GAAZ,yCACkC,OAAO,CAAC,aAD1C,CAhBF;;AAAA;AAmBJ,mBAAK,mBAAL,CAAyB,IAAI,CAAC,KAAL,CAAW,OAAO,CAAC,aAAnB,CAAzB;AAnBI;AAAA;;AAAA;AAoBC,kBAAI,OAAO,CAAC,eAAR,CAAwB,UAAxB,CAAmC,cAAnC,CAAJ,EAAwD;AAEvD,gBAAA,KAFuD,GAE/C,OAAO,CAAC,eAAR,CAAwB,KAAxB,CACZ,6CADY,CAF+C;;AAK7D,oBAAI,KAAK,IAAI,KAAK,CAAC,MAAN,KAAiB,CAA9B,EAAiC;AAC/B,uBAAK,MAAL,CAAY,GAAZ,uBAAoC,KAAK,CAAC,CAAD,CAAzC;AACI,kBAAA,GAF2B,GAEE;AAC/B,oBAAA,IAAI,EAAE,KAAK,CAAC,CAAD,CADoB;AAE/B,oBAAA,SAAS,EAAE,KAAK,CAAC,CAAD;AAFe,mBAFF;;AAM/B,sBAAI,OAAO,CAAC,aAAZ,EAA2B;AACzB,yBAAK,MAAL,CAAY,KAAZ,cACa,KAAK,CAAC,CAAD,CADlB,gCACgD,OAAO,CAAC,aADxD;AAGA,oBAAA,GAAG,CAAC,gBAAD,CAAH,GAAwB,OAAO,CAAC,aAAhC;AACD;;AACD,uBAAK,iBAAL,CAAuB,GAAvB;AACD;AACF,eAnBM,MAmBA,IAAI,OAAO,CAAC,eAAR,CAAwB,UAAxB,CAAmC,SAAS,CAAC,KAAK,EAAN,CAA5C,CAAJ,EAA4D;AAE3D,gBAAA,KAF2D,GAEnD,IAAI,MAAJ,cACD,KAAK,EADJ,qCAEZ,GAFY,CAFmD;AAM3D,gBAAA,MAN2D,GAMnD,KAAK,CAAC,IAAN,CAAW,OAAO,CAAC,eAAnB,CANmD;;AAOjE,oBAAI,MAAK,IAAI,MAAK,CAAC,MAAN,KAAiB,CAA9B,EAAiC;AACzB,kBAAA,IADyB,GAClB,kBAAkB,CAAC,MAAK,CAAC,CAAD,CAAN,CAAlB,CACV,KADU,CACJ,GADI,EAEV,MAFU,CAEsB,UAAC,GAAD,EAAM,IAAN,EAAc;AAC7C,wBAAM,EAAE,GAAG,IAAI,CAAC,KAAL,CAAW,GAAX,CAAX;AACA,2BAAQ,GAAG,GAAA,SAAA,SAAA,EAAA,EAAQ,GAAR,CAAA,sBAAc,EAAE,CAAC,CAAD,CAAhB,EAAsB,EAAE,CAAC,CAAD,CAAxB,EAAX;AACD,mBALU,EAKR,EALQ,CADkB;AAO3B,kBAAA,IAP2B,GAOE;AAC/B,oBAAA,IAAI,EAAE,IAAI,CAAC,aAAD,CAAJ,CAAoB,KAApB,CAA0B,GAA1B,EAA+B,CAA/B;AADyB,mBAPF;;AAU/B,sBAAI,OAAO,CAAC,aAAZ,EAA2B;AACzB,oBAAA,IAAG,CAAC,gBAAD,CAAH,GAAwB,OAAO,CAAC,aAAhC;AACD;;AACD,uBAAK,iBAAL,CAAuB,IAAvB;AACD;AACF;;AA7DK;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;WAgER,YACE,SADF,EAEE,QAFF,EAE8C;AAE5C,UAAI,OAAO,SAAP,IAAoB,QAAxB,EAAkC;AAChC,QAAA,SAAS,GAAG,WAAA,CAAA,WAAA,CAAY,SAAZ,CAAZ;AACD;;AACD,UAAM,UAAU,GAAG,SAAS,CAAC,KAAV,CAAgB,kCAAhB,CAAnB;AACA,UAAM,QAAQ,GAAG,SAAS,CAAC,KAAV,CAAgB,8BAAhB,CAAjB;;AACA,UAAI,UAAJ,EAAgB;AACd,aAAK,MAAL,CAAY,WAAA,CAAA,WAAA,CAAY,UAAxB,IAAsC;AACpC,UAAA,QAAQ,EAAE,QAD0B;AAEpC,UAAA,MAAM,EAAE,UAAU,CAAC,CAAD,CAAV,GAAgB,UAAU,CAAC,CAAD,CAA1B,GAAgC;AAFJ,SAAtC;AAID,OALD,MAKO,IAAI,QAAJ,EAAc;AACnB,aAAK,MAAL,CAAY,WAAA,CAAA,WAAA,CAAY,QAAxB,IAAoC;AAClC,UAAA,QAAQ,EAAR,QADkC;AAElC,UAAA,MAAM,EAAE,QAAQ,CAAC,CAAD,CAAR,GAAc,QAAQ,CAAC,CAAD,CAAtB,GAA4B;AAFF,SAApC;AAID;AACF;;;WAEO,uBAAoB,MAApB;AAAA;AAAA;AAAA;AAAA;AAAA;AAIE,cAAA,YAJF,GAI4B,MAJ5B,CAIE,YAJF,EAIgB,OAJhB,GAI4B,MAJ5B,CAIgB,OAJhB;;AAAA,oBAKF,KAAK,KAAL,IAAc,CALZ;AAAA;AAAA;AAAA;;AAAA,oBAME,IAAI,KAAJ,CAAU,sCAAV,CANF;;AAAA;AAAA,oBASF,CAAC,KAAK,UAAN,IAAoB,KAAK,SAAzB,IAAsC,CAAC,KAAK,WAT1C;AAAA;AAAA;AAAA;;AAAA;;AAAA;AAAA;AAAA;AAAA,+CAaE,KAAK,UAAL,CAAgB,OAAhB,CAAwB;AAC5B,gBAAA,QAAQ,EAAK,KAAK,WAAL,CAAiB,IAAtB,SACN,KAAK,EADC,sBAES,WAAA,CAAA,kBAFT,IAGN,KAAK,OAAL,kBAA4B,KAAK,OAAjC,GAA6C,EAHvC,CADoB;AAM5B,gBAAA,QAAQ,EAAE,KAAK,WAAL,CAAiB,QANC;AAO5B,gBAAA,KAAK,EAAE,CAPqB;AAQ5B,gBAAA,YAAY,EAAZ,YAR4B;AAS5B,gBAAA,OAAO,EAAE,OAAO,GAAG;AATS,eAAxB,CAbF;;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AA0BJ,mBAAK,KAAL;AA1BI;AAAA,+CA2BE,IAAI,OAAJ,CAAY,UAAC,CAAD;AAAA,uBAAO,UAAU,CAAC,CAAD,EAAI,IAAJ,CAAjB;AAAA,eAAZ,CA3BF;;AAAA;AAAA;AAAA,+CA4BE,KAAK,aAAL,CAAmB,MAAnB,CA5BF;;AAAA;AA8BN,mBAAK,SAAL,GAAiB,IAAjB;AA9BM;AAAA,+CA+BA,KAAK,MAAL,CAAY,GAAZ,CAAgB,kBAAhB,CA/BA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;WAkCA;AAAA;AAAA;AAAA;AAAA;AAAA,oBACF,CAAC,KAAK,UAAN,IAAoB,CAAC,KAAK,SADxB;AAAA;AAAA;AAAA;;AAAA;;AAAA;AAAA,mBAIF,KAAK,EAJH;AAAA;AAAA;AAAA;;AAAA;AAAA,+CAKE,KAAK,UAAL,CAAgB,SAAhB,CAA6B,SAAS,CAAC,KAAK,EAAN,CAAtC,QALF;;AAAA;AAAA;AAAA,+CAOA,KAAK,UAAL,CAAgB,SAAhB,CAA6B,UAA7B,QAPA;;AAAA;AAAA;AAAA,+CAQA,KAAK,UAAL,CAAgB,SAAhB,CAA6B,gBAA7B,QARA;;AAAA;AAAA;AAAA,+CASA,KAAK,UAAL,CAAgB,SAAhB,CAA6B,cAA7B,QATA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;WAYA,6BAAoB,UAApB,EAGP;AAAA;;AACC,UAAM,QAAQ,GAAG,KAAK,MAAL,CAAY,WAAA,CAAA,WAAA,CAAY,UAAxB,CAAjB;;AACA,UAAI,CAAC,QAAL,EAAe;AACb;AACD;;AACD,MAAA,MAAM,CAAC,IAAP,CAAY,UAAZ,EAAwB,OAAxB,CAAgC,UAAC,IAAD,EAAS;AACvC,YAAK,QAAQ,CAAC,MAAT,IAAmB,QAAQ,CAAC,MAAT,IAAmB,IAAvC,IAAgD,IAAI,KAAK,UAA7D,EAAyE;AACvE;AACD;;AACD,YAAM,WAAW,GAAG,UAAU,CAAC,UAAD,CAA9B;AACA,YAAI,KAAK,GAAG,UAAU,CAAC,IAAD,CAAtB;AACA,YAAM,SAAS,GAAG,OAAO,UAAU,CAAC,IAAD,CAAnC;;AACA,YAAI,SAAS,KAAK,QAAd,IAA0B,KAAK,CAAC,KAApC,EAA2C;AACzC,UAAA,KAAK,GAAG,KAAK,CAAC,KAAd;AACD;;AACA,QAAA,QAAQ,CAAC,QAAT,CAAuC;AACtC,UAAA,IAAI,EAAE,IADgC;AAEtC,UAAA,KAAK,EAAL,KAFsC;AAGtC,UAAA,OAAO,EAAE,WAH6B;AAItC,UAAA,GAAG,EAAE,kBAAkC,OAAlC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,qDACG,KAAK,YAAL,qBACH,IADG,EACI;AACN,sBAAA,EAAE,EAAE,GADE;AAEN,sBAAA,EAAE,EAAE,OAAO,GAAG,OAAH,qBAFL;AAGN,sBAAA,EAAE,EAAE,WAHE;AAIN,sBAAA,KAAK,EAAL;AAJM,qBADJ,EADH;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,YASH,IATG,CASE,MATF;AAJiC,SAAvC;AAeF,OAzBD;AA0BD;;;WAEO,2BAAkB,OAAlB,EAAgD;AACtD,UAAM,QAAQ,GAAG,KAAK,MAAL,CAAY,WAAA,CAAA,WAAA,CAAY,QAAxB,CAAjB;;AACA,UAAI,CAAC,QAAL,EAAe;AACb;AACD;;AACD,UAAI,QAAQ,CAAC,MAAT,IAAmB,QAAQ,CAAC,MAAT,IAAmB,OAAO,CAAC,IAAlD,EAAwD;AACtD;AACD;;AAEA,MAAA,QAAQ,CAAC,QAAT,CAAsC;AACrC,QAAA,IAAI,EAAE,OAAO,CAAC,IADuB;AAErC,QAAA,cAAc,EAAE,OAAO,CAAC,cAFa;AAGrC,QAAA,SAAS,EAAE,OAAO,CAAC,SAHkB;AAIrC,QAAA,KAAK,EAAE,kBAEL,MAFK,EAGL,OAHK;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,mDAKC,KAAK,UAAL,CAAgB,OAAhB,EAAyB,OAAO,CAAC,SAAjC,EAA4C,MAA5C,CALD;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,UAWL,IAXK,CAWA,IAXA;AAJ8B,OAAtC;AAiBF;;;WAEO,oBACN,OADM,EAEN,SAFM,EAGN,MAHM;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,oBAKF,CAAC,KAAK,UAAN,IAAoB,CAAC,KAAK,SALxB;AAAA;AAAA;AAAA;;AAAA;;AAAA;AAAA,mBAQF,SARE;AAAA;AAAA;AAAA;;AASA,cAAA,GATA,GASM,IAAI,wBAAA,CAAA,OAAJ,CAAY,OAAZ,CATN;AAUA,cAAA,cAVA,GAUiB,GAVjB;;AAWJ,kBAAI,MAAM,IAAI,MAAM,IAAI,YAAA,CAAA,oBAAA,CAAqB,KAA7C,EAAoD;AAClD,gBAAA,cAAc,GAAG,GAAjB;AACD;;AACD,cAAA,GAAG,CAAC,eAAJ,4BAA6C,cAA7C,eAAqE,SAArE;AAdI;AAAA,+CAeE,KAAK,UAAL,CAAgB,IAAhB,CAAqB,GAArB,CAfF;;AAAA;AAAA;AAAA;;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;WAqBD,oBAAW,QAAX,EAA0C;AAC/C,WAAK,MAAL,CAAY,WAAZ,CAAwB,QAAxB;AACA,WAAK,MAAL,CAAY,GAAZ,uBAAoC,QAApC;AACD;;;WAEM,oBACL,QADK,EAEL,WAFK,EAGL,QAHK,EAIL,QAJK;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,oBAMD,CAAC,KAAK,UAAN,IAAoB,CAAC,KAAK,SAA1B,IAAuC,CAAC,KAAK,WAN5C;AAAA;AAAA;AAAA;;AAAA,iDAOI;AAAE,gBAAA,MAAM,EAAE,CAAC,CAAX;AAAc,gBAAA,YAAY,EAAE;AAA5B,eAPJ;;AAAA;AAAA;AAAA,+CAWa,KAAK,cACV,KAAK,WAAL,CAAiB,IADP,iBACuB,KAAK,EAD5B,2BACoD,iBADpD,EAErB;AACE,gBAAA,MAAM,EAAE,MADV;AAEE,gBAAA,IAAI,EAAE,IAAI,CAAC,SAAL,CAAe;AACnB,kBAAA,QAAQ,EAAE;AADS,iBAAf,CAFR;AAKE,gBAAA,OAAO,EAAE;AACP,kBAAA,aAAa,EAAE,KAAK,WAAL,CAAiB,QADzB;AAEP,kCAAgB;AAFT;AALX,eAFqB,CAXlB;;AAAA;AAWC,cAAA,GAXD;;AAAA,oBAwBD,GAAG,IAAI,GAAG,CAAC,MAAJ,IAAc,GAArB,IAA4B,GAAG,CAAC,MAAJ,GAAa,GAxBxC;AAAA;AAAA;AAAA;;AAAA;AAAA,+CAyBa,GAAG,CAAC,IAAJ,EAzBb;;AAAA;AAyBH,cAAA,OAzBG;;AA0BH,kBAAI,QAAQ,IAAI,QAAQ,KAAK,QAA7B,EAAuC;AACrC,gBAAA,QAAQ,GAAG,OAAA,CAAA,4BAAA,CACT,YAAA,CAAA,KAAA,CAAY,IAAZ,CAAiB,WAAA,CAAA,OAAA,CAAS,GAAT,CAAa,MAA9B,EAAsC,QAAtC,CADS,CAAX;AAGD;;AA9BE;AAAA,+CA+BqB,KAAK,cAChB,OAAO,CAAC,QADQ,SACI,OAAO,CAAC,aADZ,SAC6B,OAAO,CAAC,QADrC,GACgD,OAAO,CAAC,QADxD,EAE3B;AACE,gBAAA,MAAM,EAAE,KADV;AAEE,gBAAA,OAAO,EAAE;AACP,kCAAgB,YADT;AAEP,+BAAa,IAAI,IAAJ,GAAW,WAAX,EAFN;AAGP,kCAAgB,WAHT;AAIP,yCAAqB,QAAQ,CAAC,MAJvB;AAKP,+EAA0D,QAA1D,OALO;AAMP,oCAAkB;AANX,iBAFX;AAUE,gBAAA,IAAI,EAAE,QAAQ,CAAC;AAVjB,eAF2B,CA/B1B;;AAAA;AA+BG,cAAA,SA/BH;;AAAA,mBA8CC,SA9CD;AAAA;AAAA;AAAA;;AA+CK,cAAA,KA/CL,GA+CmC;AAClC,gBAAA,aAAa,EAAE,OAAO,CAAC,aADW;AAElC,gBAAA,SAAS,EAAE,SAAS,CAAC,MAAV,IAAoB,GAApB,IAA2B,SAAS,CAAC,MAAV,GAAmB,GAFvB;AAGlC,gBAAA,UAAU,EAAE,SAAS,CAAC,MAHY;AAIlC,gBAAA,iBAAiB,EAAE,SAAS,CAAC;AAJK,eA/CnC;AAAA;AAAA,+CAsDK,KAAK,cACE,KAAK,WAAL,CAAiB,IADnB,iBACmC,KAAK,EADxC,yCAC8E,iBAD9E,EAET;AACE,gBAAA,MAAM,EAAE,MADV;AAEE,gBAAA,IAAI,EAAE,IAAI,CAAC,SAAL,CAAe,KAAf,CAFR;AAGE,gBAAA,OAAO,EAAE;AACP,kBAAA,aAAa,EAAE,KAAK,WAAL,CAAiB,QADzB;AAEP,kCAAgB;AAFT;AAHX,eAFS,CAtDV;;AAAA;AAAA,8BAkES,SAAS,CAAC,MAlEnB;;AAAA,oBAoEG,SAAS,CAAC,MAAV,IAAoB,GAApB,IAA2B,SAAS,CAAC,MAAV,GAAmB,GApEjD;AAAA;AAAA;AAAA;;AAAA,8BAqEO,SArEP;AAAA;AAAA;;AAAA;AAAA;AAAA,+CAsEa,SAAS,CAAC,IAAV,EAtEb;;AAAA;AAAA;;AAAA;AAAA;AAAA;AAkEC,gBAAA,MAlED;AAmEC,gBAAA,YAnED;AAAA;;AAAA;AAAA,8BA0EY,GAAG,CAAC,MA1EhB;AAAA;AAAA,+CA0E4C,GAAG,CAAC,IAAJ,EA1E5C;;AAAA;AAAA;AAAA;AA0EI,gBAAA,MA1EJ;AA0EwB,gBAAA,YA1ExB;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;WArYP,iCACE,gBADF,EAEE,MAFF,EAEsB;AAEpB,UAAM,KAAK,GAAG,OAAA,CAAA,qBAAA,CAAsB,gBAAtB,CAAd;AACA,aAAO,IAAI,UAAJ,CACL,KAAK,CAAC,QADD,EAEL,EAFK,EAGL,WAAA,CAAA,YAAA,CAAa,WAHR,EAIL,KAJK,EAKL,MALK,CAAP;AAOD;;;;;;AAnCH,OAAA,CAAA,OAAA,GAAA,UAAA","sourceRoot":"","sourcesContent":["\"use strict\";\n// Copyright (c) Luca Druda. All rights reserved.\n// Licensed under the MIT license. See LICENSE file in the project root for full license information.\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst interfaces_1 = require(\"./types/interfaces\");\nconst constants_1 = require(\"./types/constants\");\nconst consoleLogger_1 = require(\"./consoleLogger\");\nconst provision_1 = __importDefault(require(\"./provision\"));\nconst react_native_paho_mqtt_1 = require(\"react-native-paho-mqtt\");\nrequire(\"react-native-get-random-values\");\nconst uuid_1 = require(\"uuid\");\nconst enc_base64_1 = require(\"crypto-js/enc-base64\");\nconst crypto_js_1 = __importDefault(require(\"crypto-js\"));\nconst utils_1 = require(\"./utils\");\nconst myStorage = {\n    setItem: (key, item) => {\n        myStorage[key] = item;\n    },\n    getItem: (key) => myStorage[key],\n    removeItem: (key) => {\n        delete myStorage[key];\n    },\n};\nconst TOPIC_TWIN = \"$iothub/twin/res\";\nconst TOPIC_PROPERTIES = \"$iothub/twin/PATCH/properties/desired\";\nconst TOPIC_COMMANDS = \"$iothub/methods/POST\";\nconst TOPIC_C2D = (id) => `devices/${id}/messages/devicebound`;\nconst HTTPS_API_VERSION = \"2018-06-30\";\nclass IoTCClient {\n    constructor(id, scopeId, authenticationType, options, logger) {\n        this.id = id;\n        this.scopeId = scopeId;\n        this.authenticationType = authenticationType;\n        this.options = options;\n        this.endpoint = constants_1.DPS_DEFAULT_ENDPOINT;\n        this.connected = false;\n        if (typeof authenticationType == \"string\") {\n            this.authenticationType =\n                constants_1.IOTC_CONNECT[authenticationType.toUpperCase()];\n        }\n        if (logger) {\n            this.logger = logger;\n        }\n        else {\n            this.logger = new consoleLogger_1.ConsoleLogger();\n        }\n        if (this.authenticationType !== constants_1.IOTC_CONNECT.CONN_STRING) {\n            this.deviceProvisioning = provision_1.default.createKeyClient(this.endpoint, id, scopeId, authenticationType, options);\n        }\n        this.events = {};\n        this.retry = 0;\n        this.receivedDisconnession = false;\n    }\n    isConnected() {\n        return this.connected;\n    }\n    static getFromConnectionString(connectionString, logger) {\n        const creds = utils_1.parseConnectionString(connectionString);\n        return new IoTCClient(creds.deviceId, \"\", constants_1.IOTC_CONNECT.CONN_STRING, creds, logger);\n    }\n    setGlobalEndpoint(endpoint) {\n        this.endpoint = endpoint;\n        this.logger.log(`Endpoint set to ${endpoint}.`);\n    }\n    setModelId(modelId) {\n        this.modelId = modelId;\n    }\n    async sendTelemetry(payload, properties) {\n        if (!this.mqttClient || !this.isConnected()) {\n            throw new Error(\"Device not connected\");\n        }\n        let topic = `devices/${this.id}/messages/events/`;\n        if (properties) {\n            Object.keys(properties).forEach((prop, index) => {\n                topic = `${topic}${encodeURIComponent(prop)}=${encodeURIComponent(properties[prop])}`;\n                if (index < properties.length - 1) {\n                    topic = `${topic}&`;\n                }\n            });\n        }\n        let msg = new react_native_paho_mqtt_1.Message(JSON.stringify(payload));\n        msg.destinationName = topic;\n        return this.mqttClient.send(msg);\n    }\n    async sendProperty(property) {\n        if (!this.mqttClient || !this.isConnected()) {\n            throw new Error(\"Device not connected\");\n        }\n        let msg = new react_native_paho_mqtt_1.Message(JSON.stringify(property));\n        msg.destinationName = `$iothub/twin/PATCH/properties/reported/?$rid=${uuid_1.v4()}`;\n        return this.mqttClient.send(msg);\n    }\n    async disconnect() {\n        var _a;\n        // immediately flag disconnession, 'onconnectionlost' callbacks won't fire and reconnection won't happen\n        this.receivedDisconnession = true;\n        await this.logger.log(`Disconnecting client...`);\n        await ((_a = this.mqttClient) === null || _a === void 0 ? void 0 : _a.disconnect());\n        delete this.mqttClient;\n        this.mqttClient = undefined;\n        this.connected = false;\n    }\n    async connect(opts) {\n        var _a, _b, _c, _d, _e, _f, _g;\n        const config = Object.assign({ cleanSession: false, timeout: 30 }, opts);\n        await this.logger.log(`Connecting client ${this.id} ...`);\n        (_a = config.cancellationToken) === null || _a === void 0 ? void 0 : _a.throwIfCancelled(\"Start connection\");\n        this.credentials = await utils_1.promiseTimeout(this.deviceProvisioning\n            ? // use dps\n                this.deviceProvisioning.register.bind(this.deviceProvisioning, this.modelId)\n            : // use connection string\n                () => Promise.resolve(this.options), config.timeout * 1000);\n        (_b = config.cancellationToken) === null || _b === void 0 ? void 0 : _b.throwIfCancelled(\"Provisioning\");\n        await this.logger.debug(`Got credentials from DPS\\n${JSON.stringify(this.credentials)}`);\n        this.mqttClient = new react_native_paho_mqtt_1.Client({\n            uri: `wss://${this.credentials.host}:443/$iothub/websocket`,\n            clientId: this.id,\n            storage: myStorage,\n            webSocket: WebSocket,\n        });\n        (_c = config.cancellationToken) === null || _c === void 0 ? void 0 : _c.throwIfCancelled(\"Hub client init\");\n        this.mqttClient.on(\"connectionLost\", async (responseObject) => {\n            if (this.receivedDisconnession) {\n                // if disconnect was called from outside, don't try reconnection\n                return;\n            }\n            this.connected = false;\n            if (responseObject.errorCode !== 0) {\n                await this.logger.debug(responseObject.errorMessage);\n            }\n            // restart retry\n            this.retry = 0;\n            await utils_1.promiseTimeout(this.clientConnect.bind(this, config), config.timeout * 1000);\n            await this.subscribe();\n        });\n        this.mqttClient.on(\"messageReceived\", this.onMessageReceived.bind(this));\n        (_d = config.cancellationToken) === null || _d === void 0 ? void 0 : _d.throwIfCancelled(\"Connection callbacks applied\");\n        await utils_1.promiseTimeout(this.clientConnect.bind(this, config), config.timeout * 1000);\n        (_e = config.cancellationToken) === null || _e === void 0 ? void 0 : _e.throwIfCancelled(\"Hub connection completed\");\n        await this.subscribe();\n        (_f = config.cancellationToken) === null || _f === void 0 ? void 0 : _f.throwIfCancelled(\"Hub topic subscriptions\");\n        await this.fetchTwin();\n        (_g = config.cancellationToken) === null || _g === void 0 ? void 0 : _g.throwIfCancelled(\"Fetch Twin\");\n    }\n    async fetchTwin() {\n        if (this.mqttClient && this.connected) {\n            let twinMsg = new react_native_paho_mqtt_1.Message(\"\");\n            twinMsg.destinationName = `$iothub/twin/GET/?$rid=${uuid_1.v4()}`;\n            await this.mqttClient.send(twinMsg);\n        }\n    }\n    async onMessageReceived(message) {\n        if (message.destinationName.startsWith(`${TOPIC_TWIN}/200`)) {\n            // twin\n            await this.logger.debug(`Received twin message: ${message.payloadString}`);\n            try {\n                this.twin = JSON.parse(message.payloadString);\n                if (this.twin.desired) {\n                    this.onPropertiesUpdated(this.twin.desired);\n                }\n            }\n            catch (e) {\n                this.twin = null;\n            }\n        }\n        else if (message.destinationName.startsWith(TOPIC_PROPERTIES)) {\n            // desired properties\n            await this.logger.log(`Received desired property message: ${message.payloadString}`);\n            this.onPropertiesUpdated(JSON.parse(message.payloadString));\n        }\n        else if (message.destinationName.startsWith(TOPIC_COMMANDS)) {\n            // commands\n            const match = message.destinationName.match(/\\$iothub\\/methods\\/POST\\/(.+)\\/\\?\\$rid=(.+)/);\n            if (match && match.length === 3) {\n                this.logger.log(`Received command ${match[1]}.`);\n                let cmd = {\n                    name: match[1],\n                    requestId: match[2],\n                };\n                if (message.payloadString) {\n                    this.logger.debug(`Command ${match[1]} received with payload '${message.payloadString}'`);\n                    cmd[\"requestPayload\"] = message.payloadString;\n                }\n                this.onCommandReceived(cmd);\n            }\n        }\n        else if (message.destinationName.startsWith(TOPIC_C2D(this.id))) {\n            // c2d\n            const regex = new RegExp(`devices/${this.id}/messages/devicebound/([\\\\S]+)`, \"g\");\n            const match = regex.exec(message.destinationName);\n            if (match && match.length === 2) {\n                const data = decodeURIComponent(match[1])\n                    .split(\"&\")\n                    .reduce((obj, item) => {\n                    const kv = item.split(\"=\");\n                    return (obj = Object.assign(Object.assign({}, obj), { [kv[0]]: kv[1] }));\n                }, {});\n                let cmd = {\n                    name: data[\"method-name\"].split(\":\")[1],\n                };\n                if (message.payloadString) {\n                    cmd[\"requestPayload\"] = message.payloadString;\n                }\n                this.onCommandReceived(cmd);\n            }\n        }\n    }\n    on(eventName, callback) {\n        if (typeof eventName == \"number\") {\n            eventName = constants_1.IOTC_EVENTS[eventName];\n        }\n        const properties = eventName.match(/^Properties$|Properties\\.([\\S]+)/); // matches \"Properties\" or \"Properties.propertyname\"\n        const commands = eventName.match(/^Commands$|Commands\\.([\\S]+)/);\n        if (properties) {\n            this.events[constants_1.IOTC_EVENTS.Properties] = {\n                callback: callback,\n                filter: properties[1] ? properties[1] : undefined,\n            };\n        }\n        else if (commands) {\n            this.events[constants_1.IOTC_EVENTS.Commands] = {\n                callback,\n                filter: commands[1] ? commands[1] : undefined,\n            };\n        }\n    }\n    async clientConnect(config) {\n        const { cleanSession, timeout } = config;\n        if (this.retry == 5) {\n            throw new Error(\"No connection after multiple retries\");\n        }\n        if (!this.mqttClient || this.connected || !this.credentials) {\n            return;\n        }\n        try {\n            await this.mqttClient.connect({\n                userName: `${this.credentials.host}/${this.id}/?api-version=${constants_1.IOTHUB_API_VERSION}${this.modelId ? `&model-id=${this.modelId}` : \"\"}`,\n                password: this.credentials.password,\n                delay: 5,\n                cleanSession,\n                timeout: timeout * 1000,\n            });\n        }\n        catch (ex) {\n            // retry\n            this.retry++;\n            await new Promise((r) => setTimeout(r, 2000)); // give 2 seconds before retrying\n            await this.clientConnect(config);\n        }\n        this.connected = true;\n        await this.logger.log(\"Device connected\");\n    }\n    async subscribe() {\n        if (!this.mqttClient || !this.connected) {\n            return;\n        }\n        if (this.id) {\n            await this.mqttClient.subscribe(`${TOPIC_C2D(this.id)}/#`);\n        }\n        await this.mqttClient.subscribe(`${TOPIC_TWIN}/#`);\n        await this.mqttClient.subscribe(`${TOPIC_PROPERTIES}/#`);\n        await this.mqttClient.subscribe(`${TOPIC_COMMANDS}/#`);\n    }\n    onPropertiesUpdated(properties) {\n        const listener = this.events[constants_1.IOTC_EVENTS.Properties];\n        if (!listener) {\n            return;\n        }\n        Object.keys(properties).forEach((prop) => {\n            if ((listener.filter && listener.filter != prop) || prop === \"$version\") {\n                return;\n            }\n            const propVersion = properties[\"$version\"];\n            let value = properties[prop];\n            const valueType = typeof properties[prop];\n            if (valueType === \"object\" && value.value) {\n                value = value.value;\n            }\n            listener.callback({\n                name: prop,\n                value,\n                version: propVersion,\n                ack: async function (message) {\n                    await this.sendProperty({\n                        [prop]: {\n                            ac: 200,\n                            ad: message ? message : `Property applied`,\n                            av: propVersion,\n                            value,\n                        },\n                    });\n                }.bind(this),\n            });\n        });\n    }\n    onCommandReceived(command) {\n        const listener = this.events[constants_1.IOTC_EVENTS.Commands];\n        if (!listener) {\n            return;\n        }\n        if (listener.filter && listener.filter != command.name) {\n            return;\n        }\n        // confirm reception first\n        listener.callback({\n            name: command.name,\n            requestPayload: command.requestPayload,\n            requestId: command.requestId,\n            reply: async function (status, message) {\n                await this.ackCommand(message, command.requestId, status);\n                // await this.sendProperty({\n                //   [command.name as string]: {\n                //     value: message,\n                //   },\n                // });\n            }.bind(this),\n        });\n    }\n    async ackCommand(message, requestId, status) {\n        if (!this.mqttClient || !this.connected) {\n            return;\n        }\n        if (requestId) {\n            let msg = new react_native_paho_mqtt_1.Message(message);\n            let responseStatus = 200;\n            if (status && status == interfaces_1.IIoTCCommandResponse.ERROR) {\n                responseStatus = 500;\n            }\n            msg.destinationName = `$iothub/methods/res/${responseStatus}/?$rid=${requestId}`;\n            await this.mqttClient.send(msg);\n        }\n        else {\n            return;\n        }\n    }\n    setLogging(logLevel) {\n        this.logger.setLogLevel(logLevel);\n        this.logger.log(`Log level set to ${logLevel}`);\n    }\n    async uploadFile(fileName, contentType, fileData, encoding) {\n        if (!this.mqttClient || !this.connected || !this.credentials) {\n            return { status: -1, errorMessage: \"Client is not connected!\" };\n        }\n        let filereq;\n        //init upload\n        const res = await fetch(`https://${this.credentials.host}/devices/${this.id}/files?api-version=${HTTPS_API_VERSION}`, {\n            method: \"POST\",\n            body: JSON.stringify({\n                blobName: fileName,\n            }),\n            headers: {\n                Authorization: this.credentials.password,\n                \"Content-Type\": \"application/json\",\n            },\n        });\n        if (res && res.status >= 200 && res.status < 300) {\n            filereq = await res.json();\n            if (encoding && encoding === \"base64\") {\n                fileData = utils_1.CryptJsWordArrayToUint8Array(enc_base64_1.parse.bind(crypto_js_1.default.enc.Base64)(fileData));\n            }\n            const uploadRes = await fetch(`https://${filereq.hostName}/${filereq.containerName}/${filereq.blobName}${filereq.sasToken}`, {\n                method: \"PUT\",\n                headers: {\n                    \"x-ms-version\": \"2015-02-21\",\n                    \"x-ms-date\": new Date().toUTCString(),\n                    \"Content-Type\": contentType,\n                    \"Content-Length\": `${fileData.length}`,\n                    \"x-ms-blob-content-disposition\": `attachment; filename=\"${fileName}\"`,\n                    \"x-ms-blob-type\": \"BlockBlob\",\n                },\n                body: fileData.buffer,\n            });\n            if (uploadRes) {\n                const notif = {\n                    correlationId: filereq.correlationId,\n                    isSuccess: uploadRes.status >= 200 && uploadRes.status < 300,\n                    statusCode: uploadRes.status,\n                    statusDescription: uploadRes.statusText,\n                };\n                // file has been created\n                await fetch(`https://${this.credentials.host}/devices/${this.id}/files/notifications?api-version=${HTTPS_API_VERSION}`, {\n                    method: \"POST\",\n                    body: JSON.stringify(notif),\n                    headers: {\n                        Authorization: this.credentials.password,\n                        \"Content-Type\": \"application/json\",\n                    },\n                });\n                return {\n                    status: uploadRes.status,\n                    errorMessage: uploadRes.status >= 200 && uploadRes.status < 300\n                        ? undefined\n                        : await uploadRes.text(),\n                };\n            }\n        }\n        return { status: res.status, errorMessage: await res.text() };\n    }\n}\nexports.default = IoTCClient;\n//# sourceMappingURL=client.js.map"]},"metadata":{},"sourceType":"script"}